
# =============================================================================
CHATGPT_INSTRUCTION:
forget_previous = true
context = this_file
later_files_override = true
todo_mode = if_present
default_reply = "understand all: Awaiting your instructions."
# =============================================================================            
### BEGIN CHATGPT_INSTRUCTION            
# ðŸš¨ INSTRUCTION FOR CHATGPT ðŸš¨
#
# This file is a combined snapshot of only the Django model files.
# It contains:
#   - All Python model files under apps/*/models/
#
# Purpose:
#   - Forget all previously remembered source code in this chat.
#   - Only keep THIS file as the single source of truth.
#   - When the user uploads this file in a new chat, reset context.
#   - Later uploaded individual files override the versions here.
#
# Rules:
#   - Do NOT suggest schema changes blindly.
#   - Always respect definitions and order in this file.
#   - Keep answers focused, avoid code duplication unless asked.
#
# Special:
#   - If a file named `chatgpt_todo.txt` is included at the end,
#     treat it as the active task list and follow it literally.
#   - If no such file exists, you MUST ONLY reply with exactly:
#       "understand all: Awaiting your instructions."
#     Do NOT add examples, do NOT summarize, do NOT guess.
### END CHATGPT_INSTRUCTION
# =============================================================================



# ===== FILE: apps/core/models/organization.py =====
# apps/core/models/organization.py
"""
Purpose:
    Master data table for organizations (tenants/mandants).
    Provides a scoped context for all other business entities.

Context:
    Every business object (customer, supplier, product, pricing, etc.)
    is linked to an Organization via org_code.

Fields:
    - org_code (SmallInteger, PK): Unique code identifying the organization.
    - org_description (CharField): Optional description/name.

Constraints:
    - org_code is the primary key.
    - No additional constraints defined.

Example:
    >>> from apps.core.models import Organization
    >>> org = Organization.objects.create(org_code=1, org_description="Main Company")
    >>> str(org)
    'Main Company'
"""


from __future__ import annotations
from django.db import models


class Organization(models.Model):
    """Organization (Mandant) master data."""

    org_code = models.SmallIntegerField(
        primary_key=True,
        help_text="Business code for the organization (small integer).",
    )
    org_description = models.CharField(
        max_length=200,
        blank=True,
        help_text="Optional description/name of the organization.",
    )

    class Meta:
        verbose_name = "Organization"
        verbose_name_plural = "Organizations"

    def __str__(self) -> str:
        return f"{self.org_description or 'Organization'}"



# ===== FILE: apps/core/models/currency.py =====
# apps/core/models/currency.py
"""
Purpose:
    Reference table for ISO-4217 currencies.
    Stores currency code, name, symbol, decimal precision, and active status.

Context:
    Used throughout the system to enforce consistent currency handling
    (pricing, procurement, sales, finance).

Fields:
    - code (CharField, PK): ISO 4217 currency code (e.g., "USD", "EUR").
    - name (CharField): Full currency name (e.g., "US Dollar").
    - symbol (CharField): Display symbol (e.g., "$", "â‚¬").
    - decimal_places (SmallInteger): Allowed decimals (0â€“6; EUR=2).
    - is_active (Bool): Whether this currency is active.
    - created_at / updated_at: System timestamps, DB-managed.

Constraints:
    - decimal_places must be between 0 and 6.

Example:
    >>> from apps.core.models import Currency
    >>> eur = Currency.objects.create(code="EUR", name="Euro", symbol="â‚¬", decimal_places=2)
    >>> str(eur)
    'EUR â€” Euro'
"""





from __future__ import annotations

from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db.models.functions import Now


class Currency(models.Model):
    """ISO-4217 WÃ¤hrungen mit Anzeige-Infos und Aktiv-Flag."""

    # code CHAR(3) PRIMARY KEY
    code = models.CharField(primary_key=True, max_length=3)

    name = models.CharField(max_length=100)
    symbol = models.CharField(max_length=8, null=True, blank=True)

    # 0..6 (EUR=2) â€“ validieren in App + DB
    decimal_places = models.SmallIntegerField(
        validators=[MinValueValidator(0), MaxValueValidator(6)]
    )

    is_active = models.BooleanField(default=True)

    # DB setzt Timestamps (keine auto_now*; wir spiegeln nur die Spalten)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"{self.code} â€” {self.name}"




# ===== FILE: apps/imports/models/import_data_type.py =====
# apps/imports/models/import_data_type.py
"""
Purpose:
    Defines the available datatypes for mapping and transformation during imports.
    Ensures consistent typing when parsing external data sources into the system.

Context:
    Part of the `imports` app. Used by the import framework to validate and
    transform incoming values into the correct Python representation.

Fields:
    - code (CharField, 30, unique): Short code identifier (e.g., "str", "int", "decimal").
    - description (CharField, 100): Human-readable label for the type.
    - python_type (CharField, 50): Python type or handler string (e.g., "decimal.Decimal").

Relations:
    - No direct foreign keys. Acts as a reference/master table.

Used by:
    - Import pipeline and mapping services to resolve field datatypes.
    - Validation logic for ensuring correct type conversion.

Depends on:
    - Django ORM

Example:
    >>> from apps.imports.models import ImportDataType
    >>> t = ImportDataType.objects.create(
    ...     code="bool",
    ...     description="Boolean",
    ...     python_type="bool"
    ... )
    >>> print(t)
    bool (Boolean)
"""


from __future__ import annotations
from django.db import models


class ImportDataType(models.Model):
    """
    Defines available datatypes for mapping transformations.
    Examples: string, integer, decimal, boolean, date, datetime, json.
    """

    code = models.CharField(
        max_length=30,
        unique=True,
        help_text="Short code identifier (e.g., 'str', 'int', 'decimal', 'bool').",
    )

    description = models.CharField(
        max_length=100,
        help_text="Human-readable description (e.g., 'String', 'Integer').",
    )

    python_type = models.CharField(
        max_length=50,
        help_text="Target Python type or handler (e.g., 'str', 'int', 'decimal.Decimal').",
    )

    class Meta:
        verbose_name = "Import Data Type"
        verbose_name_plural = "Import Data Types"

    def __str__(self) -> str:
        return f"{self.code} ({self.description})"



# ===== FILE: apps/imports/models/import_global_default_line.py =====
# apps/imports/models/import_global_default_line.py
"""
Purpose:
    Represents a single line entry within a global default set for imports.
    Each line maps a target field path to a default value, optionally with
    a transform and enforced datatype.

Context:
    Belongs to the imports domain. Used when building base dictionaries of
    defaults (e.g., for products, variants, suppliers) before mapping raw
    import data. Provides consistent fallback values across an organization.

Fields:
    - set (FK â†’ ImportGlobalDefaultSet): The owning default set.
    - target_path (CharField, 255): Path of the field (e.g., "product.name").
    - default_value (JSONField): The fallback value for this path.
    - transform (FK â†’ ImportTransformType): Optional transform to apply.
    - is_required (BooleanField): Whether the field must be present.
    - target_datatype (FK â†’ ImportDataType): Defines the expected datatype.

Relations:
    - ImportGlobalDefaultSet â†’ multiple ImportGlobalDefaultLine
    - ImportTransformType â†’ multiple ImportGlobalDefaultLine
    - ImportDataType â†’ multiple ImportGlobalDefaultLine

Used by:
    - apps/imports/services/defaults.py (build_base_dict, applying defaults)

Depends on:
    - apps.imports.models.import_global_default_set.ImportGlobalDefaultSet
    - apps.imports.models.import_data_type.ImportDataType
    - apps.imports.models.import_transform_type.ImportTransformType

Example:
    >>> from apps.imports.models import ImportGlobalDefaultLine
    >>> line = ImportGlobalDefaultLine.objects.create(
    ...     set=default_set,
    ...     target_path="product.state_code",
    ...     default_value="active",
    ...     target_datatype=dt_str
    ... )
    >>> print(line)
    product.state_code = active
"""


from __future__ import annotations
from django.db import models
from apps.imports.models.import_global_default_set import ImportGlobalDefaultSet
from apps.imports.models.import_data_type import ImportDataType
from apps.imports.models.import_transform_type import ImportTransformType


class ImportGlobalDefaultLine(models.Model):
    """
    Line items for global defaults.
    Each entry defines a target path and a default value.
    """

    set = models.ForeignKey(
        ImportGlobalDefaultSet,
        on_delete=models.CASCADE,
        related_name="global_default_lines",
    )

    target_path = models.CharField(max_length=255)
    default_value = models.JSONField(null=True, blank=True)

    # statt CharField â†’ FK
    transform = models.ForeignKey(
        ImportTransformType,
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="default_lines",
        help_text="Transform to apply to this field (FK instead of free text).",
    )

    is_required = models.BooleanField(default=False)

    target_datatype = models.ForeignKey(
        ImportDataType,
        on_delete=models.PROTECT,
        related_name="default_lines",
        help_text="Datatype for this default value (e.g., str, int, decimal)."
    )

    class Meta:
        verbose_name = "Import Global Default Line"
        verbose_name_plural = "Import Global Default Lines"
        constraints = [
            models.UniqueConstraint(
                fields=["set", "target_path"],
                name="uq_globaldefaultline_set_target"
            )
        ]

    def __str__(self) -> str:
        return f"{self.target_path} = {self.default_value}"


# ===== FILE: apps/imports/models/import_global_default_set.py =====
# apps/imports/models/import_global_default_set.py
"""
Purpose:
    Represents the head record for global default configurations that apply
    to all suppliers within an organization. Each set has a description and
    validity date that determines which defaults are active at a given time.

Context:
    Part of the imports domain. Used as a container for multiple
    ImportGlobalDefaultLine entries that define specific default values.
    Provides versioning of defaults by validity period.

Fields:
    - organization (FK â†’ core.Organization): Owner of the default set.
    - description (CharField, 255): Human-readable description.
    - valid_from (DateField): Start date from which the defaults are active.
    - created_at (DateTimeField): Timestamp when the set was created.

Relations:
    - Organization â†’ multiple ImportGlobalDefaultSet
    - ImportGlobalDefaultSet â†’ multiple ImportGlobalDefaultLine

Used by:
    - apps/imports/services/defaults.py (get_active_default_set, build_base_dict)

Depends on:
    - apps.core.models.Organization
    - apps.imports.models.import_global_default_line.ImportGlobalDefaultLine

Example:
    >>> from apps.imports.models import ImportGlobalDefaultSet
    >>> default_set = ImportGlobalDefaultSet.objects.create(
    ...     organization=org,
    ...     description="Default product values",
    ...     valid_from="2025-01-01",
    ... )
    >>> print(default_set)
    Default product values (from 2025-01-01)
"""


from __future__ import annotations
from django.db import models


class ImportGlobalDefaultSet(models.Model):
    """
    Head table for global defaults that apply to all suppliers.
    Each set has a validity period and a description.
    """
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="global_default_sets",
    )

    description = models.CharField(max_length=255)
    valid_from = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Import Global Default Set"
        verbose_name_plural = "Import Global Default Sets"
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "valid_from"],
                name="uq_globaldefaultset_org_validfrom",
            )
        ]

    def __str__(self) -> str:
        return f"{self.description} (from {self.valid_from})"


# ===== FILE: apps/imports/models/import_error_log.py =====
# apps/imports/models/import_error_log.py
"""
Purpose:
    Logs errors that occur during the import process while transforming
    raw records into structured ERP tables.

Context:
    Part of the `imports` app. Provides visibility into failures when
    processing ImportRawRecord entries inside an ImportRun.

Fields:
    - import_run (FK â†’ imports.ImportRun): The run during which the error occurred.
    - line_number (IntegerField, nullable): Source line number in the raw file.
    - error_message (TextField): Description of the error encountered.
    - payload (JSONField, nullable): Optional snapshot of the input data.
    - created_at (DateTimeField): Timestamp when the error was logged.

Relations:
    - ImportRun â†’ multiple ImportErrorLogs

Used by:
    - Import framework to persist errors for later inspection.
    - Admin/UI for debugging failed imports.

Depends on:
    - apps.imports.models.ImportRun
    - Django ORM

Example:
    >>> from apps.imports.models import ImportErrorLog, ImportRun
    >>> run = ImportRun.objects.first()
    >>> ImportErrorLog.objects.create(
    ...     import_run=run,
    ...     line_number=42,
    ...     error_message="Invalid price format",
    ...     payload={"sku": "X123", "price": "abc"}
    ... )
    <ImportErrorLog: Error in run 1 line 42: Invalid price format>
"""


from __future__ import annotations

from django.db import models


class ImportErrorLog(models.Model):
    """
    Table for logging errors that occur while mapping ImportRawRecord
    entries into structured ERP tables.
    """

    import_run = models.ForeignKey(
        "imports.ImportRun",
        on_delete=models.CASCADE,
        related_name="error_logs",
    )
    line_number = models.IntegerField(null=True, blank=True)
    error_message = models.TextField()
    payload = models.JSONField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Import Error Log"
        verbose_name_plural = "Import Error Logs"

    def __str__(self) -> str:
        return f"Error in run {self.import_run_id} line {self.line_number}: {self.error_message}"


#
# Beispiel:
#
# from apps.imports.models.import_error_log import ImportErrorLog
# from apps.imports.models.import_run import ImportRun
#
# run = ImportRun.objects.first()
# ImportErrorLog.objects.create(
#     import_run=run,
#     line_number=42,
#     error_message="Invalid price format",
#     payload={"Part Number": "X123", "Listenpreis": "abc"}
# )
#
# -> erzeugt einen neuen Fehler-Logeintrag, der spÃ¤ter im Admin sichtbar ist.




# ===== FILE: apps/imports/models/import_raw_record.py =====
# apps/imports/models/import_raw_record.py
"""
Purpose:
    Stores raw unmodified data from supplier or customer imports. Acts as the
    first persistence layer for payloads before transformation or validation.

Context:
    Belongs to the imports domain. Each ImportRawRecord links to an ImportRun
    and captures a single line/item from the input (JSON, XML, CSV, etc.).
    Used for auditing, debugging, error handling, and retries.

Fields:
    - import_run (FK â†’ ImportRun): The import run this record belongs to.
    - line_number (IntegerField): Sequential number within the run (starting at 1).
    - payload (JSONField): Full raw payload from the external source.
    - supplier_product_reference (CharField, 255, optional): Supplierâ€™s identifier
      (SKU, part number) for fast lookup.
    - product_is_imported / price_is_imported (BooleanField): Flags whether
      this record was successfully imported into ERP/price tables.
    - product_imported_at / price_imported_at (DateTimeField, optional): Timestamps
      for successful imports.
    - is_product_import_error / is_price_import_error (BooleanField): Flags whether
      import attempts failed.
    - error_message_product_import / error_message_price_import (TextField, optional):
      Detailed error messages for failed imports.
    - retry_count_product_import / retry_count_price_import (PositiveIntegerField):
      Number of retries attempted for this record.

Relations:
    - ImportRun â†’ multiple ImportRawRecord (1:n).

Used by:
    - Import pipelines for auditing, retry handling, and debugging.
    - Error logging/reporting systems.

Depends on:
    - apps.imports.models.ImportRun

Example:
    >>> from apps.imports.models import ImportRawRecord, ImportRun
    >>> run = ImportRun.objects.first()
    >>> rec = ImportRawRecord.objects.create(
    ...     import_run=run,
    ...     line_number=1,
    ...     payload={"Part Number": "X123", "Price": "12.50"},
    ...     supplier_product_reference="X123",
    ... )
    >>> print(rec)
    Run 1, line 1, ref=X123
"""


from __future__ import annotations
from django.db import models
from django.utils import timezone


class ImportRawRecord(models.Model):
    """
    Raw import storage for supplier/customer integrations.
    Stores unmodified payloads (JSON, XML, CSV rows, etc.) for auditing, error handling and reprocessing.
    """

    import_run = models.ForeignKey(
        "imports.ImportRun",
        on_delete=models.CASCADE,
        related_name="raw_records",
        help_text="Import run this record belongs to.",
    )

    line_number = models.IntegerField(
        help_text="Sequential line number within the import run (starting at 1)."
    )

    payload = models.JSONField(
        help_text="Full raw payload from the external source (JSON or converted dict)."
    )

    supplier_product_reference = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_index=True,
        help_text="Supplier's article reference (e.g., supplier SKU or manufacturer number) for fast lookup.",
    )

    product_is_imported = models.BooleanField(
        default=False,
        help_text="True if this record has been successfully imported into ERP tables.",
    )

    price_is_imported = models.BooleanField(
        default=False,
        help_text="True if this record has been successfully imported into price tables.",
    )


    product_imported_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp when this record was imported.",
    )

    price_imported_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp when pricing was imported.",
    )

    is_product_import_error = models.BooleanField(
        default=False,
        help_text="True if processing this record failed.",
    )

    is_price_import_error = models.BooleanField(
        default=False,
        help_text="True if processing this record failed.",
    )


    error_message_product_import = models.TextField(
        null=True,
        blank=True,
        help_text="Detailed error message if processing failed.",
    )

    error_message_price_import = models.TextField(
        null=True,
        blank=True,
        help_text="Detailed error message if processing failed.",
    )


    retry_count_product_import = models.PositiveIntegerField(
        default=0,
        help_text="Number of times this record has been retried for processing.",
    )

    retry_count_price_import = models.PositiveIntegerField(
        default=0,
        help_text="Number of times this record has been retried for processing.",
    )

    class Meta:
        verbose_name = "Import Raw Record"
        verbose_name_plural = "Import Raw Records"
        constraints = [
            models.UniqueConstraint(
                fields=["import_run", "line_number"],
                name="uniq_import_run_line",
            )
        ]
        indexes = [
        #     models.Index(fields=["supplier_product_reference"], name="idx_rawrecord_supplier_ref"),
              models.Index(fields=["product_is_imported"], name="idx_rawrecord_product_imported"),
              models.Index(fields=["price_is_imported"], name="idx_rawrecord_price_imported"),
        #     models.Index(fields=["is_product_import_error"], name="idx_rawrecord_product_error"),
        #     models.Index(fields=["is_price_import_error"], name="idx_rawrecord_price_error"),
        #     models.Index(fields=["product_is_imported", "import_run_id"], name="idx_rawrecord_product_imported_run),"
        #     models.Index(fields=["price_is_imported", "import_run_id"], name="idx_rawrecord_price_imported_run),"
        ]

    def __str__(self) -> str:
        return (
            f"Run {self.import_run_id}, line {self.line_number}, "
            f"ref={self.supplier_product_reference or 'n/a'}"
        )


# ===== FILE: apps/imports/models/import_map_set.py =====
# apps/imports/models/import_map_set.py
"""
Purpose:
    Represents a configuration set that defines how raw import data from a
    supplier and source type should be mapped into the ERP structure.

Context:
    Part of the imports domain. Each ImportMapSet groups multiple
    ImportMapDetail entries that specify field-level mapping rules.
    Defines which mapping applies for a given supplier and source type,
    with a start date of validity.

Fields:
    - organization (FK â†’ core.Organization): The organization this mapping belongs to.
    - supplier (FK â†’ partners.Supplier): The supplier providing the import data.
    - source_type (FK â†’ imports.ImportSourceType): The type of import source (file, API, etc.).
    - description (CharField, 255): Human-readable description of the mapping set.
    - valid_from (DateField): Date from which this mapping is effective.
    - created_at (DateTimeField): Timestamp when the mapping set was created.

Relations:
    - Organization â†’ multiple ImportMapSet
    - Supplier â†’ multiple ImportMapSet
    - ImportSourceType â†’ multiple ImportMapSet
    - ImportMapSet â†’ multiple ImportMapDetail (child rules)

Used by:
    - Import processing engine to determine which mapping rules to apply
      for supplier imports.
    - apps.imports.models.import_map_detail.ImportMapDetail

Depends on:
    - apps.core.models.Organization
    - apps.partners.models.Supplier
    - apps.imports.models.import_source_type.ImportSourceType

Example:
    >>> from apps.imports.models import ImportMapSet
    >>> ms = ImportMapSet.objects.create(
    ...     organization=org,
    ...     supplier=supplier,
    ...     source_type=src_type,
    ...     description="Default CSV mapping",
    ...     valid_from="2025-01-01",
    ... )
    >>> print(ms)
    SUPP01 / file (from 2025-01-01)
"""

from __future__ import annotations
from django.db import models


class ImportMapSet(models.Model):
    """
    Head table for import mapping configurations.
    Defines which mapping applies to a supplier + source type,
    with a validity period.
    """

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="import_map_sets",
    )

    supplier = models.ForeignKey(
        "partners.Supplier",
        on_delete=models.PROTECT,
        related_name="import_map_sets",
    )

    source_type = models.ForeignKey(
        "imports.ImportSourceType",
        on_delete=models.PROTECT,
        related_name="import_map_sets",
        help_text="Import source type (e.g., file, API, CSV, Excel).",
    )

    description = models.CharField(max_length=255)

    valid_from = models.DateField(
        help_text="Date from which this mapping is valid."
    )

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name = "Import Map Set"
        verbose_name_plural = "Import Map Sets"
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "supplier", "source_type", "valid_from"],
                name="uq_mapset_org_supplier_type_validfrom",
            )
        ]

    def __str__(self) -> str:
        return f"{self.supplier.supplier_code} / {self.source_type.code} (from {self.valid_from})"


# ===== FILE: apps/imports/models/import_map_detail.py =====
# apps/imports/models/import_map_detail.py
"""
Purpose:
    Represents a single mapping rule that defines how a field from the source
    import payload is transformed and assigned to a standardized target path.

Context:
    Part of the imports domain. Each ImportMapDetail belongs to an
    ImportMapSet, forming a collection of rules that describe how to
    process supplier or external data into the ERP structure.

Fields:
    - map_set (FK â†’ ImportMapSet): Parent set grouping related map details.
    - source_path (CharField, 255): Path of the source field in the raw payload.
    - target_path (CharField, 255): Path in the standardized dict where the
      value will be stored.
    - target_datatype (FK â†’ ImportDataType): Datatype the value should be
      converted to.
    - transform (CharField, 50, nullable): Optional transformation to apply
      (e.g., uppercase, decimal).
    - is_required (BooleanField): Marks if the target field is mandatory.

Relations:
    - ImportMapSet â†’ multiple ImportMapDetail
    - ImportDataType â†’ multiple ImportMapDetail

Used by:
    - Import processing pipeline to transform raw supplier data.
    - apps.imports.services.transform_utils.apply_transform

Depends on:
    - apps.imports.models.import_map_set.ImportMapSet
    - apps.imports.models.import_data_type.ImportDataType

Example:
    >>> from apps.imports.models import ImportMapDetail, ImportMapSet, ImportDataType
    >>> dt = ImportDataType.objects.get(code="decimal")
    >>> ms = ImportMapSet.objects.first()
    >>> detail = ImportMapDetail.objects.create(
    ...     map_set=ms,
    ...     source_path="Listenpreis",
    ...     target_path="price.price",
    ...     target_datatype=dt,
    ...     transform="decimal",
    ...     is_required=True,
    ... )
    >>> print(detail)
    Listenpreis â†’ price.price (decimal)
"""

from __future__ import annotations
from django.db import models
from apps.imports.models.import_map_set import ImportMapSet
from apps.imports.models.import_data_type import ImportDataType


class ImportMapDetail(models.Model):
    """
    Line items for import mapping.
    Each entry defines how to map a field from the source payload
    to a target path in the standardized dict.
    """

    map_set = models.ForeignKey(
        ImportMapSet,
        on_delete=models.CASCADE,
        related_name="map_details",
    )

    source_path = models.CharField(
        max_length=255,
        help_text="Path in the source payload (e.g., 'translated.name', 'Artikelnummer').",
    )

    target_path = models.CharField(
        max_length=255,
        help_text="Path in the standardized dict (e.g., 'product.name', 'price.price').",
    )

    target_datatype = models.ForeignKey(
        ImportDataType,
        on_delete=models.PROTECT,
        related_name="map_details",
        help_text="Datatype the target value should be converted to.",
    )

    transform = models.CharField(
        max_length=50,
        null=True,
        blank=True,
        help_text="Optional transform function to apply (e.g., 'upper', 'decimal').",
    )

    is_required = models.BooleanField(
        default=False,
        help_text="If true, the target field must be present after mapping.",
    )

    class Meta:
        verbose_name = "Import Map Detail"
        verbose_name_plural = "Import Map Details"
        constraints = [
            models.UniqueConstraint(
                fields=["map_set", "source_path", "target_path"],
                name="uq_mapdetail_set_source_target",
            )
        ]

    def __str__(self) -> str:
        return f"{self.source_path} â†’ {self.target_path} ({self.target_datatype.code})"


# ===== FILE: apps/imports/models/import_transform_type.py =====
# apps/imports/models/import_transform_type.py
"""
Purpose:
    Registry of supported transformation functions used in import mapping.
    Provides a unique code and description for each transform.

Context:
    Part of the imports domain. Transform types define how raw values
    from import payloads should be processed before saving.

Fields:
    - code (CharField, 50, unique): Identifier of the transform (e.g., "uppercase", "int").
    - description (CharField, 255): Human-readable description of the transformation.

Relations:
    - ImportTransformType â†’ multiple ImportGlobalDefaultLines (1:n).
    - ImportTransformType â†’ used in mapping definitions (FKs).

Used by:
    - ImportGlobalDefaultLine (transform FK).
    - Mapping and ETL logic to dynamically apply transforms.

Depends on:
    - Django ORM.

Example:
    >>> from apps.imports.models import ImportTransformType
    >>> t = ImportTransformType.objects.create(code="uppercase", description="Convert text to upper case")
    >>> print(t)
    uppercase â€” Convert text to upper case
"""


from __future__ import annotations
from django.db import models


class ImportTransformType(models.Model):
    """
    Central registry for all supported transforms.
    Example: uppercase, lowercase, strip, int, decimal, bool
    """

    code = models.CharField(
        max_length=50,
        unique=True,
        help_text="Unique code for this transform (e.g., uppercase, int, bool).",
    )
    description = models.CharField(
        max_length=255,
        help_text="Human-readable description of what this transform does.",
    )

    class Meta:
        verbose_name = "Import Transform Type"
        verbose_name_plural = "Import Transform Types"
        ordering = ["code"]

    def __str__(self) -> str:
        return f"{self.code} â€” {self.description}"



# ===== FILE: apps/imports/models/import_source_type.py =====
# apps/imports/models/import_source_type.py
"""
Purpose:
    Defines available import source types (e.g., file, API, manual).
    Serves as a reference table for categorizing import runs and mappings.

Context:
    Part of the imports domain. Each ImportRun references an ImportSourceType
    to indicate where the data originated from. Used in mapping and logging.

Fields:
    - code (CharField, 20, unique): Short identifier (e.g., "file", "api").
    - description (CharField, 100): Human-readable description.

Relations:
    - ImportSourceType â†’ multiple ImportRuns (1:n).
    - ImportSourceType â†’ multiple ImportMapSets (1:n).

Used by:
    - ImportRun (source_type FK).
    - ImportMapSet (source_type FK).

Depends on:
    - Django ORM (constraints, unique checks).

Example:
    >>> from apps.imports.models import ImportSourceType
    >>> t = ImportSourceType.objects.create(code="file", description="File Import")
    >>> print(t)
    file â€” File Import
"""


from __future__ import annotations
from django.db import models


class ImportSourceType(models.Model):
    """
    Reference table for different import source types
    (e.g., file, API, manual, other).
    """

    code = models.CharField(
        max_length=20,
        unique=True,
        help_text="Short machine-readable code (e.g., 'file', 'api')."
    )
    description = models.CharField(
        max_length=100,
        help_text="Human-readable description of the source type."
    )

    class Meta:
        verbose_name = "Import Source Type"
        verbose_name_plural = "Import Source Types"

    def __str__(self) -> str:
        return f"{self.code} â€” {self.description}"



# ===== FILE: apps/imports/models/import_run.py =====
# apps/imports/models/import_run.py
"""
Purpose:
    Represents a single supplier import execution (header record).
    Tracks metadata about the run, including timing, status, source, and counts.

Context:
    Belongs to the imports domain. Each ImportRun serves as the parent entity
    for ImportRawRecord entries and error logs. Used to monitor the lifecycle
    of an import job.

Fields:
    - supplier (FK â†’ Supplier): Supplier this run belongs to.
    - source_type (FK â†’ ImportSourceType): Type of source (e.g., file, API, CSV).
    - source_file (CharField, 500, optional): Path or identifier of the imported file.
    - started_at (DateTimeField): Timestamp when the import started.
    - finished_at (DateTimeField, optional): Timestamp when the import finished.
    - status (CharField, 20): Run status ("running", "success", "failed").
    - total_records (IntegerField, optional): Number of raw records fetched.
    - is_processed (BooleanField): Whether the run has been processed into ERP tables.
    - processed_at (DateTimeField, optional): Timestamp when records were processed.

Relations:
    - Supplier â†’ multiple ImportRuns (1:n).
    - ImportRun â†’ multiple ImportRawRecord (1:n).
    - ImportRun â†’ multiple ImportErrorLog (1:n).

Used by:
    - Import pipelines for execution tracking and reporting.
    - Error logging and auditing mechanisms.

Depends on:
    - apps.partners.models.Supplier
    - apps.imports.models.ImportSourceType

Example:
    >>> from apps.imports.models import ImportRun
    >>> run = ImportRun.objects.create(
    ...     supplier=supplier,
    ...     source_type=source_type,
    ...     source_file="/imports/supplier_2025-01.csv"
    ... )
    >>> print(run)
    ImportRun 1 â€” SUPPLIERX at 2025-01-10 12:00
"""


from __future__ import annotations
from django.db import models
from django.utils import timezone


class ImportRun(models.Model):
    """
    Represents a single supplier import execution (the header).
    Tracks metadata and overall status of the import process.
    """

    supplier = models.ForeignKey(
        "partners.Supplier",
        on_delete=models.PROTECT,
        related_name="import_runs",
        help_text="Supplier this import run belongs to."
    )

    source_type = models.ForeignKey(
        "imports.ImportSourceType",
        on_delete=models.PROTECT,
        related_name="import_runs",
        help_text="Type of source for this import (e.g., file, API)."
    )

    source_file = models.CharField(
        max_length=500,
        help_text="Absolute or relative path to the source file that was imported.",
        null=True,
        blank=True,
    )

    started_at = models.DateTimeField(default=timezone.now)
    finished_at = models.DateTimeField(null=True, blank=True)
    status = models.CharField(
        max_length=20,
        default="running",
        help_text="running, success, failed"
    )
    total_records = models.IntegerField(
        null=True,
        blank=True,
        help_text="Number of raw records fetched in this run."
    )

    is_processed = models.BooleanField(
        default=False,
        help_text="Marks whether this run has already been processed into ERP tables."
    )

    processed_at = models.DateTimeField(
        null=True,
        blank=True,
        help_text="Timestamp when raw records were processed into ERP tables."
    )

    class Meta:
        verbose_name = "Import Run"
        verbose_name_plural = "Import Runs"

    def __str__(self) -> str:
        return f"ImportRun {self.id} â€” {self.supplier.supplier_code} at {self.started_at:%Y-%m-%d %H:%M}"



# ===== FILE: apps/pricing/models/currency_rate.py =====
# apps/core/models/currency_rate.py
"""
Purpose:
    Represents daily exchange rates between two currencies.
    Stores conversion factors (base â†’ quote) with full precision
    and enforces uniqueness per date.

Context:
    Part of the core app. Used by pricing, procurement, and reporting
    to convert between currencies for transactions and analytics.

Fields:
    - base (FK â†’ core.Currency): Base currency of the rate.
    - quote (FK â†’ core.Currency): Quote currency of the rate.
    - rate (DecimalField, 16,8): Conversion factor (e.g., 1.12345678).
    - rate_date (DateField): Date the rate applies to.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Currency (base) â†’ multiple CurrencyRates
    - Currency (quote) â†’ multiple CurrencyRates

Used by:
    - Pricing and ERP calculations
    - Reports requiring currency normalization
    - Procurement processes involving multi-currency suppliers

Depends on:
    - apps.core.models.Currency
    - Django ORM (constraints, validators)

Example:
    >>> from apps.core.models import CurrencyRate, Currency
    >>> usd = Currency.objects.get(code="USD")
    >>> eur = Currency.objects.get(code="EUR")
    >>> cr = CurrencyRate.objects.create(base=usd, quote=eur, rate="0.92345678", rate_date="2025-09-26")
    >>> print(cr)
    USD/EUR @ 0.92345678 (2025-09-26)
"""

from __future__ import annotations

from django.db import models
from django.core.validators import MinValueValidator
from django.db.models.functions import Now
from django.db.models import Q


class CurrencyRate(models.Model):
    #id = models.BigAutoField(primary_key=True)

    base = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="base_rates",
    )
    quote = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="quote_rates",
    )

    rate = models.DecimalField(max_digits=16, decimal_places=8, validators=[MinValueValidator(0.00000001)])
    rate_date = models.DateField()

    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"{self.base_id}/{self.quote_id} @ {self.rate} ({self.rate_date})"

    class Meta:
        #db_table = "currency_rate"
        # indexes = [
        #     models.Index(fields=("rate_date",), name="idx_currency_rate_date"),
        #     models.Index(fields=("base", "quote"), name="idx_currency_rate_base_quote"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("base", "quote", "rate_date"),
                name="uniq_currency_rate",
            ),
            models.CheckConstraint(
                name="ck_currency_rate_positive",
                check=Q(rate__gt=0),
            ),
        ]


# ===== FILE: apps/pricing/models/price_group.py =====
# apps/pricing/models/price_group.py
"""
Purpose:
    Represents a logical grouping of prices within an organization.
    Allows categorization of product or customer prices into groups
    such as retail, wholesale, or special contract pricing.

Context:
    Belongs to the pricing domain. PriceGroups are used to define
    customer-specific or organization-specific pricing structures.

Fields:
    - organization (FK â†’ core.Organization): The owning organization.
    - price_group_code (CharField, max 20): Unique code per organization.
    - price_group_description (CharField, max 200): Optional descriptive name.

Relations:
    - Organization â†’ multiple PriceGroups
    - Referenced by PriceList or SalesChannelVariantPrice
      to determine applicable prices.

Used by:
    - Pricing logic for ERP/shops
    - Import routines that map supplier/customer pricing
    - Reporting modules for analyzing price segmentation

Depends on:
    - apps.core.models.Organization

Example:
    >>> from apps.pricing.models import PriceGroup
    >>> pg = PriceGroup.objects.create(
    ...     organization=org,
    ...     price_group_code="WHOLESALE",
    ...     price_group_description="Wholesale customer pricing"
    ... )
    >>> print(pg)
    WHOLESALE â€” Wholesale customer pricing
"""


from __future__ import annotations
from django.db import models


class PriceGroup(models.Model):
    """Price group master data, scoped by organization."""

    # Force 32-bit PK (SERIAL-like). Remove to use project default (BigAutoField).
   # id = models.AutoField(primary_key=True)

    # FK to core.Organization(org_code); DB column stays 'org_code'
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,  # ON DELETE RESTRICT equivalent
        related_name="price_groups",
    )

    price_group_code = models.CharField(
        max_length=20,
        help_text="Price group code (unique within organization).",
    )
    price_group_description = models.CharField(
        max_length=200,
        blank=True,
        help_text="Optional description/name of the price group.",
    )

    class Meta:
        #db_table = "price_group"
        verbose_name = "Price Group"
        verbose_name_plural = "Price Groups"
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "price_group_code"],
                name="uniq_price_group_org_code",
            )
        ]
        # indexes = [
        #     models.Index(fields=["organization"], name="idx_price_group_org"),
        # ]

    def __str__(self) -> str:
        return f"{self.price_group_code} â€” {self.price_group_description or 'Price Group'}"


# ===== FILE: apps/pricing/models/tax_class.py =====
# apps/pricing/models/tax_class.py
"""
Purpose:
    Defines tax classes for products and services, including name and rate.
    Used to determine applicable tax percentages (e.g., 19% VAT).

Context:
    Part of the pricing domain. Each TaxClass represents a distinct taxation
    rule that can be applied to price calculations in ERP and shop systems.

Fields:
    - name (CharField, unique): Human-readable name for the tax class (e.g., "Standard VAT").
    - rate (DecimalField, 5,4): Tax rate as a decimal fraction (0â€“1, e.g., 0.1900 = 19%).
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - May be referenced by products, price rules, or invoice logic in other models.

Used by:
    - Pricing and billing systems to apply the correct tax rate
    - ERP processes for compliance and reporting
    - Import and catalog services for mapping external tax definitions

Depends on:
    - Django ORM (validation and constraints)

Example:
    >>> from apps.pricing.models import TaxClass
    >>> vat = TaxClass.objects.create(name="Standard VAT", rate="0.1900")
    >>> print(vat)
    Standard VAT (0.1900)
"""


from __future__ import annotations

from django.db import models
from django.core.validators import MinValueValidator, MaxValueValidator
from django.db.models.functions import Now
from django.db.models import Q


class TaxClass(models.Model):
    #id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=100, unique=True)
    rate = models.DecimalField(
        max_digits=5, decimal_places=4,
        validators=[MinValueValidator(0), MaxValueValidator(1)]
    )

    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"{self.name} ({self.rate})"

    class Meta:
        db_table = "tax_class"
        indexes = [
            models.Index(fields=("rate",), name="idx_tax_class_rate"),
        ]
        constraints = [
            models.CheckConstraint(
                name="ck_tax_class_rate",
                check=Q(rate__gte=0) & Q(rate__lte=1),
            ),
        ]




# ===== FILE: apps/pricing/models/sales_channel_variant_price.py =====
# apps/pricing/models/sales_channel_variant_price.py
"""
Purpose:
    Represents the price of a specific ChannelVariant within a PriceList.
    Each record defines the value of a variantâ€™s price in a given sales channel
    for a specific time period.

Context:
    Belongs to the pricing domain. Used to track sales prices across
    different channels (shops, marketplaces) and supports time-based
    validity for price changes.

Fields:
    - organization (FK â†’ core.Organization): The owning organization.
    - price_list (FK â†’ pricing.PriceList): The price list this price belongs to.
    - channel_variant (FK â†’ catalog.ChannelVariant): The sales channel + variant.
    - valid_from (DateTimeField): Timestamp when the price becomes effective.
    - price (DecimalField): The actual price (non-negative, up to 12,4 digits).
    - valid_to (DateTimeField): Optional end date for the price validity.
    - need_update (BooleanField): Whether the price requires a sync/update.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple SalesChannelVariantPrices
    - PriceList â†’ multiple SalesChannelVariantPrices
    - ChannelVariant â†’ multiple SalesChannelVariantPrices

Used by:
    - Pricing services to fetch current or historical prices
    - Import and sync jobs to update shop/marketplace prices
    - ERP processes for reporting and analytics

Depends on:
    - apps.core.models.Organization
    - apps.pricing.models.PriceList
    - apps.catalog.models.ChannelVariant

Example:
    >>> from apps.pricing.models import SalesChannelVariantPrice
    >>> scvp = SalesChannelVariantPrice.objects.create(
    ...     organization=org,
    ...     price_list=pl,
    ...     channel_variant=cv,
    ...     valid_from="2025-01-01T00:00:00Z",
    ...     price="99.9900"
    ... )
    >>> print(scvp)
    [org=1] RETAIL-2025/ChannelVariant(123) @ 99.9900 from 2025-01-01 00:00:00
"""


from __future__ import annotations

from django.db import models
from django.core.validators import MinValueValidator
from django.db.models import Q
from django.db.models.functions import Now


class SalesChannelVariantPrice(models.Model):
    # id = models.BigAutoField(primary_key=True)

    # Organization
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="sales_channel_variant_prices",
    )

    # Relations
    price_list = models.ForeignKey(
        "pricing.PriceList",
        on_delete=models.PROTECT,
        related_name="sales_channel_variant_prices",
    )

    channel_variant = models.ForeignKey(
        "catalog.ChannelVariant",
        on_delete=models.PROTECT,
        related_name="sales_channel_variant_prices",
    )

    valid_from = models.DateTimeField()

    # Values / timeframe
    price = models.DecimalField(
        max_digits=12,
        decimal_places=4,
        validators=[MinValueValidator(0)],
    )

    valid_to = models.DateTimeField(null=True, blank=True)
    need_update = models.BooleanField(default=False)  # Flag to indicate if the price needs to be updated

    # DB defaults (Postgres sets timestamps)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return (
            f"[org={self.organization}] {self.price_list}/{self.channel_variant} "
            f"@ {self.price} from {self.valid_from}"
        )

    class Meta:
        # db_table = "price"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_price_org"),
        #     models.Index(fields=("price_list", "channel_variant"), name="idx_price_pricelist_variant"),
        #     models.Index(fields=("channel_variant", "price_list"), name="idx_price_variant_pricelist"),
        #     models.Index(fields=("valid_from",), name="idx_price_valid_from"),
        #     # Partial index (current price): valid_to IS NULL
        #     models.Index(
        #         fields=("price_list", "channel_variant"),
        #         name="idx_price_current",
        #         condition=Q(valid_to__isnull=True),
        #     ),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "price_list", "channel_variant", "valid_from"),
                name="uniq_channel_var_price_valid",
            ),
            models.CheckConstraint(
                check=Q(price__gte=0),
                name="ck_price_price_nonneg",
            ),
        ]



# ===== FILE: apps/pricing/models/price_list.py =====
# apps/pricing/models/price_list.py
"""
Purpose:
    Represents a price list definition within an organization.
    Each price list groups together prices in a given currency and
    can be used for either sales or procurement contexts.

Context:
    Belongs to the pricing domain. PriceLists are the containers for
    product/variant pricing records and are associated with a single currency.

Fields:
    - organization (FK â†’ core.Organization): The owning organization.
    - price_list_code (CharField, max 20): Unique code per organization.
    - price_list_description (CharField, max 200): Human-readable description.
    - kind (CharField, max 1): Type of list, 'S' (sales) or 'P' (procurement).
    - currency (FK â†’ core.Currency): Currency of all prices in this list.
    - is_active (BooleanField): Whether the price list is active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple PriceLists
    - Currency â†’ multiple PriceLists
    - PriceList â†’ referenced by price detail tables (e.g., variant prices)

Used by:
    - Sales processes to fetch customer price lists
    - Procurement processes to manage supplier price lists
    - Pricing services and ERP import routines

Depends on:
    - apps.core.models.Organization
    - apps.core.models.Currency

Example:
    >>> from apps.pricing.models import PriceList
    >>> pl = PriceList.objects.create(
    ...     organization=org,
    ...     price_list_code="RETAIL-2025",
    ...     price_list_description="Retail price list for 2025",
    ...     kind="S",
    ...     currency=eur
    ... )
    >>> print(pl)
    [Org1] RETAIL-2025 (S)
"""


from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class PriceList(models.Model):
    #id = models.AutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="price_lists",
    )

    price_list_code = models.CharField(max_length=20)
    price_list_description = models.CharField(max_length=200)
    kind = models.CharField(max_length=1)  # 'S' or 'P'

    currency = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="price_lists",
    )

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[{self.organization}] {self.price_list_code} ({self.kind})"

    class Meta:
        # db_table = "price_list"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_price_list_org"),
        #     models.Index(fields=("is_active",), name="idx_price_list_active"),
        #     models.Index(fields=("kind",), name="idx_price_list_kind"),
        # ]
        constraints = [
            # (org_code, price_list_code) unique
            models.UniqueConstraint(
                fields=("organization", "price_list_code"),
                name="uniq_price_list_org_code",
            ),
            # Guard fÃ¼r Org-Konsistenz (fÃ¼r spÃ¤tere price-Guards)
            models.UniqueConstraint(
                fields=("organization", "id"),
                name="uniq_price_list_org_id",
            ),
            models.CheckConstraint(
                name="ck_price_list_kind",
                check=models.Q(kind__in=["S", "P"]),
            ),
        ]


# ===== FILE: apps/catalog/models/product_variant.py =====

# apps/catalog/models/product_variant.py
"""
Purpose:
    Defines the ProductVariant entity, which represents a sellable unit (SKU).
    Captures identifiers, logistics data, order constraints, availability,
    and marketing attributes that extend the base Product.

Context:
    Belongs to the `catalog` app. Each ProductVariant links a Product with
    its Packing, Origin, and State. Variants are the concrete SKUs used for
    procurement, pricing, stock, and sales channel operations.

Fields:
    - organization (FK â†’ core.Organization): Owning organization (multi-tenant scope).
    - product (FK â†’ catalog.Product): The base product this variant belongs to.
    - packing (FK â†’ catalog.Packing): Packaging unit of this variant.
    - origin (FK â†’ catalog.Origin): Origin classification code.
    - state (FK â†’ catalog.State): State classification code.
    - sku (CharField, 120): Internal stock-keeping unit identifier.
    - ean (CharField, 14): Standardized GTIN/EAN code (optional, indexed).
    - barcode (CharField, 64): Non-standard or supplier barcode (optional).
    - customs_code (IntegerField): Customs tariff number (optional).
    - weight / width / height / length (DecimalField): Logistics dimensions.
    - eclass_code (CharField, 16): International eCl@ss classification (optional).
    - stock_quantity / available_stock (IntegerField): Stock and availability data.
    - is_available (BooleanField): Availability flag from supplier API.
    - shipping_free (BooleanField): Free shipping flag.
    - min_purchase / max_purchase / purchase_steps (IntegerField): Order constraints.
    - is_topseller (BooleanField): Marketing flag for top seller status.
    - is_active (BooleanField): Whether this variant is active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple ProductVariants
    - Product â†’ multiple ProductVariants
    - Packing â†’ multiple ProductVariants
    - Origin â†’ multiple ProductVariants
    - State â†’ multiple ProductVariants
    - ProductVariant â†” ChannelVariant (publish variants to channels)
    - ProductVariant â†” SupplierProduct (procurement linkage)

Used by:
    - apps.catalog.models.Product
    - apps.catalog.models.ChannelVariant
    - apps.procurement.models.SupplierProduct
    - apps.pricing.models.SalesChannelVariantPrice

Depends on:
    - core.Organization
    - catalog.Product
    - catalog.Packing
    - catalog.Origin
    - catalog.State

Example:
    >>> from apps.catalog.models import ProductVariant
    >>> pv = ProductVariant.objects.create(
    ...     organization=org,
    ...     product=prod,
    ...     packing=pack,
    ...     origin=orig,
    ...     state=state,
    ...     sku="SKU-123",
    ...     ean="4006381333931",
    ...     weight="1.250",
    ... )
    >>> print(pv)
    [org=1] SKU=SKU-123 (product_id=42)
"""



from __future__ import annotations

from django.db import models
from django.db.models import CheckConstraint, Q
from django.db.models.functions import Now


class ProductVariant(models.Model):
    """
    Sellable unit (SKU). Holds SKU/EAN, packaging, logistics data,
    order constraints, availability, and marketing flags.
    """

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="product_variants",
    )
    product = models.ForeignKey(
        "catalog.Product",
        on_delete=models.PROTECT,
        related_name="product_variants",
    )
    packing = models.ForeignKey(
        "catalog.Packing",
        on_delete=models.PROTECT,
        related_name="product_variants",
    )
    origin = models.ForeignKey(
        "catalog.Origin",
        on_delete=models.PROTECT,
        related_name="product_variants",
    )
    state = models.ForeignKey(
        "catalog.State",
        on_delete=models.PROTECT,
        related_name="product_variants",
    )

    # Identity & scanning
    sku = models.CharField(max_length=120)
    ean = models.CharField(
        max_length=14,
        null=True,
        blank=True,
        db_index=True,
        help_text="Standardized GTIN/EAN code (8, 12, 13, or 14 digits).",
    )
    barcode = models.CharField(
        max_length=64,
        null=True,
        blank=True,
        help_text="Non-standard or supplier-specific barcode (may be alphanumeric).",
    )

    # Logistics & classification
    customs_code = models.IntegerField(null=True, blank=True)
    weight = models.DecimalField(max_digits=10, decimal_places=3, null=True, blank=True)
    width = models.DecimalField(max_digits=10, decimal_places=3, null=True, blank=True)
    height = models.DecimalField(max_digits=10, decimal_places=3, null=True, blank=True)
    length = models.DecimalField(max_digits=10, decimal_places=3, null=True, blank=True)

    eclass_code = models.CharField(
        max_length=16,
        null=True,
        blank=True,
        help_text="International eCl@ss classification code (e.g. 44070702).",
    )

    # Stock & availability
    stock_quantity = models.IntegerField(null=True, blank=True)
    available_stock = models.IntegerField(null=True, blank=True)
    is_available = models.BooleanField(
        default=False,
        help_text="Availability flag as provided by supplier API.",
    )
    shipping_free = models.BooleanField(default=False)

    # Order constraints
    min_purchase = models.IntegerField(default=1)
    max_purchase = models.IntegerField(null=True, blank=True)
    purchase_steps = models.IntegerField(default=1)

    # Marketing
    is_topseller = models.BooleanField(
        default=False,
        help_text="Flag indicating this variant is marked as top seller in the shop.",
    )

    is_active = models.BooleanField(default=True)

    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization}] SKU={self.sku} (product_id={self.product_id})"

    class Meta:
        constraints = [
            CheckConstraint(check=Q(weight__gte=0), name="ck_variant_weight_nonneg"),
            models.UniqueConstraint(fields=("organization", "sku"), name="uniq_variant_org_sku"),
            models.UniqueConstraint(fields=("organization", "id"), name="uniq_variant_org_id"),
            models.UniqueConstraint(
                fields=("organization", "product", "packing", "origin", "state"),
                name="uniq_variant_org_product_pack_origin_state",
            ),
        ]


# ===== FILE: apps/catalog/models/origin.py =====
#!/usr/bin/env python3

# apps/catalog/models/origin.py
"""
Purpose:
    Define origin master data using a single-letter code.
    Provides a lightweight reference for categorizing products
    or variants by their origin or classification.

Context:
    Part of the `catalog` app. Serves as a reference/master table
    used in product variant definitions to tag items with an origin
    attribute for logistics, reporting, or integration purposes.

Fields:
    - origin_code (CharField, PK, length=1): Unique single-letter code
      identifying the origin.
    - origin_description (CharField, max 100): Optional descriptive
      label or name for the origin.

Relations:
    - Referenced by ProductVariant and potentially other catalog models
      to denote the origin classification of an item.

Used by:
    - Catalog (ProductVariant)
    - Any downstream reporting or integration requiring origin info

Depends on:
    - Django ORM

Example:
    >>> from apps.catalog.models import Origin
    >>> Origin.objects.create(origin_code="E", origin_description="Europe")
    <Origin: E â€” Europe>
"""


from __future__ import annotations
from django.db import models


class Origin(models.Model):
    """Origin master data (single-letter code)."""

    origin_code = models.CharField(
        max_length=1,
        primary_key=True,
        help_text="Single-letter origin code.",
    )
    origin_description = models.CharField(
        max_length=100,
        blank=True,
        help_text="Optional description/name of the origin.",
    )

    class Meta:
        #db_table = "origin"
        verbose_name = "Origin"
        verbose_name_plural = "Origins"

    def __str__(self) -> str:
        return f"{self.origin_code} â€” {self.origin_description or 'Origin'}"



# ===== FILE: apps/catalog/models/state.py =====
#!/usr/bin/env python3
# apps/catalog/models/state.py
"""
Purpose:
    Defines the State master data entity, represented by a single-letter code.
    Used to classify product variants by condition/state within the catalog.

Context:
    Part of the `catalog` app. Each ProductVariant references a State to
    indicate its condition (e.g., new, refurbished, used).

Fields:
    - state_code (CharField, 1, PK): Single-letter identifier of the state.
    - state_description (CharField, 100): Optional descriptive label.

Relations:
    - ProductVariant â†’ references State via FK.

Used by:
    - apps.catalog.models.ProductVariant (FK relation via state)

Depends on:
    - Django ORM
    - core.Organization (indirectly via ProductVariant usage)

Example:
    >>> from apps.catalog.models import State
    >>> s = State.objects.create(state_code="N", state_description="New")
    >>> print(s)
    N â€” New
"""

from __future__ import annotations
from django.db import models


class State(models.Model):
    """State master data (single-letter code)."""

    state_code = models.CharField(
        max_length=1,
        primary_key=True,
        help_text="Single-letter state code.",
    )
    state_description = models.CharField(
        max_length=100,
        blank=True,
        help_text="Optional description/name of the state.",
    )

    class Meta:
        #db_table = "state"
        verbose_name = "State"
        verbose_name = "State"
        verbose_name_plural = "States"

    def __str__(self) -> str:
        return f"{self.state_code} â€” {self.state_description or 'State'}"



# ===== FILE: apps/catalog/models/product.py =====
# apps/catalog/models/product.py

# apps/catalog/models/product.py
"""
Purpose:
    Define master product data shared across all variants.
    Stores catalog-wide attributes such as name, manufacturer,
    part number, SEO metadata, and marketing flags.

Context:
    Part of the `catalog` app. Products serve as the base entity for
    all sellable variants (ProductVariant) and are referenced by
    channel-specific models. Provides a stable anchor for procurement,
    pricing, and shop integration.

Fields:
    - id (AutoField): Primary key.
    - organization (FK â†’ core.Organization): Owning organization.
    - name (CharField, 200): Human-readable product name.
    - slug (CharField, 200): Unique slug within an organization.
    - manufacturer (FK â†’ catalog.Manufacturer): Brand or vendor.
    - manufacturer_part_number (CharField, 100): Raw part number.
    - manufacturer_part_number_norm (GeneratedField, 100): Normalized part
      number, computed via PostgreSQL `REGEXP_REPLACE`.
    - product_group (FK â†’ catalog.ProductGroup): Classification/group.
    - description (TextField): Long product description, optional.
    - meta_title / meta_description / keywords: SEO fields.
    - is_new (Boolean): Marketing flag (new release).
    - is_closeout (Boolean): Marketing flag (discontinued).
    - release_date (DateField): Release information.
    - is_active (Boolean): Availability flag.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple Products.
    - Manufacturer â†’ multiple Products.
    - ProductGroup â†’ multiple Products.
    - Referenced by ProductVariant and ChannelVariant.

Used by:
    - Catalog (ProductVariant definitions).
    - Pricing and Procurement modules.
    - External integrations (shop systems, supplier APIs).

Depends on:
    - Django ORM
    - core.Organization
    - catalog.Manufacturer
    - catalog.ProductGroup

Example:
    >>> from apps.catalog.models import Product
    >>> Product.objects.filter(
    ...     organization__org_code=1,
    ...     is_active=True,
    ...     is_closeout=False,
    ... )
"""


from __future__ import annotations

from django.db import models
from django.db.models import F, Value, Func
from django.db.models.functions import Lower, Now


class RegexpReplace(Func):
    """PostgreSQL REGEXP_REPLACE(source, pattern, replacement [, flags])."""
    function = "REGEXP_REPLACE"
    template = "%(function)s(%(expressions)s)"


class Product(models.Model):
    """
    Product master data (shared across variants).
    Mirrors supplier API fields plus ERP/Shop attributes.
    """

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="products",
    )

    name = models.CharField(max_length=200)
    slug = models.CharField(max_length=200)

    manufacturer = models.ForeignKey(
        "catalog.Manufacturer",
        on_delete=models.PROTECT,
        related_name="products",
    )

    manufacturer_part_number = models.CharField(max_length=100)

    manufacturer_part_number_norm = models.GeneratedField(
        expression=RegexpReplace(
            RegexpReplace(
                RegexpReplace(
                    RegexpReplace(
                        RegexpReplace(
                            Lower(F("manufacturer_part_number")),
                            Value("[ÃŸáºž]"), Value("ss"), Value("g")
                        ),
                        Value("Ã¤"), Value("ae"), Value("g")
                    ),
                    Value("Ã¶"), Value("oe"), Value("g")
                ),
                Value("Ã¼"), Value("ue"), Value("g")
            ),
            Value("[^0-9a-z]+"),
            Value(""),
            Value("g"),
        ),
        output_field=models.CharField(max_length=100),
        db_persist=True,
        editable=False,
    )

    product_group = models.ForeignKey(
        "catalog.ProductGroup",
        on_delete=models.PROTECT,
    )

    description = models.TextField(
        null=True,
        blank=True,
        help_text="Full product description (rich text / HTML).",
    )

    # SEO / Marketing
    meta_title = models.CharField(max_length=255, null=True, blank=True)
    meta_description = models.TextField(null=True, blank=True)
    keywords = models.CharField(max_length=500, null=True, blank=True)

    # Shop flags
    is_new = models.BooleanField(default=False)
    is_closeout = models.BooleanField(default=False)
    release_date = models.DateField(null=True, blank=True)

    is_active = models.BooleanField(default=True)

    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[{self.organization}] {self.name} ({self.slug})"

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "slug"),
                name="uniq_product_org_slug",
            ),
            models.UniqueConstraint(
                fields=("organization", "manufacturer", "manufacturer_part_number_norm"),
                name="uniq_product_org_manu_mpn_norm",
            ),
            models.UniqueConstraint(
                fields=("organization", "id"),
                name="uniq_product_org_id",
            ),
        ]




# ===== FILE: apps/catalog/models/channel_variant.py =====
# apps/catalog/models/channel_variant.py
"""
Purpose:
    Represent the assignment of a ProductVariant to a sales Channel
    within a specific Organization. Defines availability, publishing
    flags, synchronization state, and external shop IDs.

Context:
    Part of the `catalog` app. Used to manage how product variants
    are distributed into different sales channels (e.g. webshop,
    marketplace). Central for integration and synchronization.

Fields:
    - organization (FK â†’ core.Organization): Owning organization.
    - channel (FK â†’ catalog.Channel): The sales channel.
    - variant (FK â†’ catalog.ProductVariant): The specific product variant.
    - publish (BooleanField): Flag whether this variant is published.
    - is_active (BooleanField): Active/inactive marker.
    - need_shop_update (BooleanField): Marks pending synchronization.
    - shop_product_id (CharField): External shop product identifier.
    - shop_variant_id (CharField): External shop variant identifier.
    - last_synced_at (DateTimeField): Timestamp of last synchronization.
    - last_error (TextField): Stores last sync error message.
    - meta_json (JSONField): Flexible metadata/extensions.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple ChannelVariants
    - Channel â†’ multiple ChannelVariants
    - ProductVariant â†’ multiple ChannelVariants

Used by:
    - Synchronization services to external shops
    - Pricing and publication processes
    - Monitoring/reporting of channel sync states

Depends on:
    - Django ORM
    - core.Organization
    - catalog.Channel
    - catalog.ProductVariant

Example:
    >>> from apps.catalog.models import ChannelVariant
    >>> ChannelVariant.objects.filter(channel__kind="shop", publish=True)
"""



from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now


class ChannelVariant(models.Model):
    """
    A product variant in a sales channel (e.g. a webshop).
    Links a ProductVariant to a Channel, with additional fields for
    publication status, external IDs, and metadata.
    Represents the availability and configuration of a specific product variant
    within a specific sales channel.
    Each ChannelVariant is unique per (organization, channel, variant).
    1:n relation: A ProductVariant can be linked to multiple Channels via ChannelVariant.
    1:n relation: A Channel can have multiple ProductVariants via ChannelVariant.
    1:1 relation: A ChannelVariant links exactly one ProductVariant to one Channel.
    1:1 relation: A ChannelVariant belongs to exactly one Organization.
    """
    #id = models.BigAutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="channel_variants",
    )

    channel = models.ForeignKey(
        "catalog.Channel",
        on_delete=models.PROTECT,
        related_name="channel_variants",
    )

    variant = models.ForeignKey(
        "catalog.ProductVariant",
        on_delete=models.PROTECT,
        related_name="channel_variants",
    )

    publish = models.BooleanField(default=False)
    is_active = models.BooleanField(default=True)
    need_shop_update = models.BooleanField(default=False)

    shop_product_id = models.CharField(max_length=100, null=True, blank=True)
    shop_variant_id = models.CharField(max_length=100, null=True, blank=True)

    last_synced_at = models.DateTimeField(null=True, blank=True)
    last_error = models.TextField(null=True, blank=True)

    # Postgres JSONB (Django -> JSONField)
    meta_json = models.JSONField(null=True, blank=True)

    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization}] ch={self.channel} v={self.variant} (pub={self.publish})"

    class Meta:
        # db_table = "channel_variant"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_channel_variant_org"),
        #     models.Index(fields=("channel",), name="idx_channel_variant_channel"),
        #     models.Index(fields=("variant",), name="idx_channel_variant_variant"),
        #     models.Index(fields=("publish",), name="idx_channel_variant_publish"),
        #     models.Index(fields=("is_active",), name="idx_channel_variant_active"),
        #     models.Index(fields=("need_shop_update",), name="ix_chvar_needupd"),
        #     models.Index(fields=("last_synced_at",), name="ix_chvar_lastsync"),
        # ]
        constraints = [
            # Eindeutig pro (Org, Channel, Variante)
            models.UniqueConstraint(
                fields=("organization", "channel", "variant"),
                name="uniq_channel_variant",
            ),
            # Partial-unique auf externe IDs je Channel (nur wenn gesetzt)
            # models.UniqueConstraint(
            #     fields=("channel", "shop_item_id"),
            #     name="uniq_channel_item_ext",
            #     condition=Q(shop_item_id__isnull=False) & ~Q(shop_item_id=""),
            # ),
            # models.UniqueConstraint(
            #     fields=("channel", "shop_variant_id"),
            #     name="uniq_channel_variant_ext",
            #     condition=Q(shop_variant_id__isnull=False) & ~Q(shop_variant_id=""),
            # ),
        ]



# ===== FILE: apps/catalog/models/product_media.py =====

# apps/catalog/models/product_media.py
"""
Purpose:
    Stores media assets (images, videos, documents) for products and variants.
    Each entry represents one media file with metadata, linked either to a
    Product or to a specific ProductVariant.

Context:
    Part of the `catalog` app. Used to manage product images, thumbnails,
    and other media for display in shop systems and marketplaces.

Fields:
    - id (BigAutoField): Primary key.
    - organization (FK â†’ core.Organization): Owner of the media record.
    - product (FK â†’ catalog.Product): Product to which this media belongs.
    - variant (FK â†’ catalog.ProductVariant, optional): Specific variant if media
      is variant-specific; otherwise null.
    - role (CharField, 20): Media role (e.g., "gallery", "thumbnail").
    - sort_order (SmallIntegerField): Ordering within the role group.
    - alt_text (CharField, 200): Alternative text for accessibility/SEO.
    - media_url (TextField): URL to the media file (e.g., CDN link).
    - mime (CharField, 100): MIME type if available (e.g., image/jpeg).
    - width_px / height_px (IntegerField): Dimensions of the media (optional).
    - file_size (IntegerField): File size in bytes (optional).
    - is_active (BooleanField): Active flag for filtering.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple ProductMedia
    - Product â†’ multiple ProductMedia
    - ProductVariant â†’ multiple ProductMedia (optional)

Used by:
    - apps.catalog.models.Product (reverse FK)
    - apps.catalog.models.ProductVariant (reverse FK)
    - API / frontend layers for rendering product galleries

Depends on:
    - core.Organization
    - catalog.Product
    - catalog.ProductVariant

Example:
    >>> from apps.catalog.models import ProductMedia
    >>> pm = ProductMedia.objects.create(
    ...     organization=org,
    ...     product=prod,
    ...     role="gallery",
    ...     media_url="https://cdn.example.com/img123.jpg",
    ...     alt_text="Front view of the product"
    ... )
    >>> print(pm)
    [org=1] product=123 gallery #1
"""


from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class ProductMedia(models.Model):
    id = models.BigAutoField(primary_key=True)

    # org_code SMALLINT â†’ FK core.Organization(org_code)
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="products_media",

    )

    # product / variant Bezug
    product = models.ForeignKey(
        "catalog.Product",
        on_delete=models.PROTECT,
        related_name="products_media",

    )
    variant = models.ForeignKey(
        "catalog.ProductVariant",
        on_delete=models.PROTECT,
        null=True,
        blank=True,
        related_name="products_media",
    )

    # Medien-Metadaten
    role = models.CharField(max_length=20, default="gallery")
    sort_order = models.SmallIntegerField(default=0)
    alt_text = models.CharField(max_length=200, default="", blank=True)

    media_url = models.TextField()
    mime = models.CharField(max_length=100, null=True, blank=True)
    width_px = models.IntegerField(null=True, blank=True)
    height_px = models.IntegerField(null=True, blank=True)
    file_size = models.IntegerField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        scope = f"variant={self.variant}" if self.variant else f"product={self.product}"
        return f"[org={self.organization}] {scope} {self.role} #{self.id}"

    class Meta:
        #db_table = "product_media"
        indexes = [
            models.Index(fields=("organization",), name="idx_product_media_org"),
            models.Index(fields=("product",), name="idx_product_media_product"),
            models.Index(fields=("variant",), name="idx_product_media_variant"),
            models.Index(fields=("role", "sort_order"), name="idx_product_media_role_order"),
            models.Index(fields=("is_active",), name="idx_product_media_active"),
        ]



# ===== FILE: apps/catalog/models/packing.py =====
#!/usr/bin/env python3

# apps/catalog/models/packing.py
"""
Purpose:
    Define packaging unit master data within an organization.
    Each record specifies how items are packed (e.g., single piece,
    box of 10, pallet), including codes, multipliers, and descriptions.

Context:
    Part of the `catalog` app. Used in product and procurement workflows
    to enforce packaging rules for ordering, stock management, and logistics.

Fields:
    - id (AutoField): Surrogate primary key (SERIAL in SQL).
    - organization (FK â†’ core.Organization): Owning organization,
      ensures tenant isolation.
    - packing_code (SmallIntegerField): Business code identifying
      the packing unit within an organization.
    - amount (DecimalField, NUMERIC(10,3)): Multiplier for this unit
      (default 1.000, e.g. "box of 10").
    - packing_short_description (CharField, max 20): Short label for display.
    - packing_description (CharField, max 200): Longer optional description.

Relations:
    - Organization â†’ multiple Packing definitions.
    - Referenced by ProductVariant or Procurement models for correct packaging
      and order handling.

Used by:
    - Catalog (ProductVariant definition)
    - Procurement (ordering logic, minimum order units)

Depends on:
    - Django ORM
    - core.Organization

Example:
    >>> from apps.catalog.models import Packing
    >>> Packing.objects.create(
    ...     organization=org,
    ...     packing_code=10,
    ...     amount=Decimal("10.000"),
    ...     packing_short_description="Box of 10",
    ... )
    <Packing: 10 â€” Box of 10>
"""


from __future__ import annotations

from decimal import Decimal

from django.db import models


class Packing(models.Model):
    """Represents a packaging unit definition within an organization.

    Mirrors the given SQL schema:
      CREATE TABLE packing (
          id SERIAL PRIMARY KEY,
          org_code SMALLINT NOT NULL,
          packing_code SMALLINT NOT NULL,
          amount NUMERIC(10, 3) DEFAULT 1.0,
          packing_short_description VARCHAR(20) NOT NULL,
          packing_description VARCHAR(200)
      );
      ALTER TABLE packing
        ADD CONSTRAINT fk_packing_org
          FOREIGN KEY (org_code) REFERENCES org(org_code) ON DELETE RESTRICT;
      ALTER TABLE packing
        ADD CONSTRAINT uniq_packing_packing_code_org_code
          UNIQUE (org_code, packing_code);
    """

    # Match SERIAL (int4). If the project default is BigAutoField, keep this explicit AutoField.
    #id = models.AutoField(primary_key=True)

    # FK to Organization by its code field, stored in column "org_code".
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,  # ON DELETE RESTRICT
        related_name="packings",
    )

    packing_code = models.SmallIntegerField()
    amount = models.DecimalField(
        max_digits=10,
        decimal_places=3,
        default=Decimal("1.000"),
        null=True,  # nullable in SQL; default still applies when not provided
        help_text="Multiplier amount for this packing unit.",
    )
    packing_short_description = models.CharField(max_length=20)
    packing_description = models.CharField(max_length=200, blank=True, null=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "packing_code"],
                name="uniq_packing_packing_code_org_code",
            ),
        ]
        # indexes = [
        #     models.Index(fields=["organization"], name="idx_packing_org"),
        # ]

    def __str__(self) -> str:
        """Human-readable representation used in admin and logs."""
        return f"{self.packing_code} â€” {self.packing_short_description}"


# ===== FILE: apps/catalog/models/manufacturer.py =====
#!/usr/bin/env python3

# apps/catalog/models/manufacturer.py
"""
Purpose:
    Represent manufacturer (brand or vendor) master data used in the catalog.
    Provides a stable numeric code and optional description for consistent
    brand identification across products and variants.

Context:
    Part of the `catalog` app. Serves as a reference table to associate
    products and variants with their brand/vendor for classification,
    reporting, and external integrations.

Fields:
    - manufacturer_code (SmallIntegerField, PK): Stable business code
      uniquely identifying the manufacturer.
    - manufacturer_description (CharField, max 200): Optional descriptive
      name or label for the manufacturer.

Relations:
    - Referenced by Product and ProductVariant models to indicate brand/vendor.

Used by:
    - Catalog (Product, ProductVariant)
    - Procurement and reporting modules requiring brand information

Depends on:
    - Django ORM

Example:
    >>> from apps.catalog.models import Manufacturer
    >>> Manufacturer.objects.create(manufacturer_code=101, manufacturer_description="ACME Tools")
    <Manufacturer: 101 â€” ACME Tools>
"""


from __future__ import annotations
from django.db import models


class Manufacturer(models.Model):
    """Manufacturer master data (brand/vendor entity for catalog)."""

    manufacturer_code = models.SmallIntegerField(
        primary_key=True,
        help_text="Business code for the manufacturer (small integer).",
    )
    manufacturer_description = models.CharField(
        max_length=200,
        blank=True,
        help_text="Optional description/name of the manufacturer.",
    )

    class Meta:
        #db_table = "manufacturer"
        verbose_name = "Manufacturer"
        verbose_name_plural = "Manufacturers"

    def __str__(self) -> str:
        return (
            f"{self.manufacturer_code} â€” "
            f"{self.manufacturer_description or 'Manufacturer'}"
        )


# ===== FILE: apps/catalog/models/product_group.py =====
# apps/catalog/models/product_group.py

# apps/catalog/models/product_group.py
"""
Purpose:
    Represents a grouping of products within an organization.
    Each group is identified by a short code and description.

Context:
    Part of the `catalog` app. ProductGroups provide a logical structure
    for organizing Products. Every Product must belong to one ProductGroup.
    Used in imports, seeding, and catalog management.

Fields:
    - id (AutoField): Primary key.
    - organization (FK â†’ core.Organization): Owning organization.
    - product_group_code (CharField, 20): Unique code per organization.
    - product_group_description (CharField, 200): Optional human-readable label.

Relations:
    - Organization â†’ multiple ProductGroups.
    - ProductGroup â†’ multiple Products (via FK in Product).

Used by:
    - apps/catalog/models/product.py (FK to ProductGroup).
    - Import and seeding services that build catalog structures.

Depends on:
    - Django ORM
    - core.Organization

Example:
    >>> from apps.catalog.models import ProductGroup
    >>> pg = ProductGroup.objects.create(
    ...     organization=org,
    ...     product_group_code="FILTERS",
    ...     product_group_description="Air and oil filters"
    ... )
    >>> print(pg)
    FILTERS â€” Air and oil filters
"""



from __future__ import annotations

from django.db import models


class ProductGroup(models.Model):
    """Product group master data, scoped by organization."""

    # Keep 32-bit PK (SERIAL-like) to match the previous model behavior.
    #id = models.AutoField(primary_key=True)

    # FK to core.Organization(org_code); DB column stays 'org_code'
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,  # maps to ON DELETE RESTRICT
        related_name="product_groups",
    )

    # âš  Field names remain unchanged to avoid unintended schema changes.
    product_group_code = models.CharField(
        max_length=20,
        help_text="Product group code (unique within organization).",
    )
    product_group_description = models.CharField(
        max_length=200,
        blank=True,
        help_text="Optional description/name of the product group.",
    )

    def __str__(self) -> str:
        return f"{self.item_group_code} â€” {self.item_group_description or 'Product Group'}"

    class Meta:
        verbose_name = "Product Group"
        verbose_name_plural = "Product Groups"
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "product_group_code"],
                name="uniq_product_group_org_item_group_code",
            ),
            # NEU: fÃ¼r den Composite-Guard benÃ¶tigt
            models.UniqueConstraint(
                fields=["organization", "id"],
                name="uniq_product_group_org_id",
            ),
        ]
        # indexes = [
        #     models.Index(fields=["organization"], name="idx_product_group_org_code"),
        # ]



# ===== FILE: apps/catalog/models/channel.py =====
# apps/catalog/models/channel.py
"""
Purpose:
    Define the Channel model representing a sales or distribution channel
    (e.g., webshop, marketplace) within an organization. Captures its code,
    name, kind, and base currency.

Context:
    Part of the `catalog` app. Channels represent the entry points through which
    products and prices are published. They are used in pricing, procurement,
    and integration with external systems (e.g., shops, marketplaces).

Fields:
    - id (AutoField): Primary key for the channel.
    - organization (FK â†’ core.Organization): The owning organization.
    - channel_code (CharField, max 20): Short code identifying the channel
      within an organization (unique per organization).
    - channel_name (CharField, max 200): Human-readable channel name.
    - kind (CharField, max 50): Type of channel ("shop" or "marketplace").
    - base_currency (FK â†’ core.Currency): Currency in which prices are defined.
    - is_active (BooleanField): Whether this channel is active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple Channels
    - Currency â†’ multiple Channels
    - Channel â†” Product/Variant pricing via related models (e.g. ChannelVariant)

Used by:
    - Pricing (PriceGroup, PriceList, SalesChannelVariantPrice)
    - Procurement (for supplier channel relations, if applicable)
    - Services for integration with external systems

Depends on:
    - Django ORM
    - core.Organization
    - core.Currency

Example:
    # Get all active marketplace channels for org 1
    Channel.objects.filter(organization__org_code=1, kind="marketplace", is_active=True)
"""




from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class Channel(models.Model):
    id = models.AutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="channels",
    )

    channel_code = models.CharField(max_length=20)
    channel_name = models.CharField(max_length=200)

    kind = models.CharField(max_length=50, default="shop")  # 'shop' | 'marketplace'

    base_currency = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="channels",

    )

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[{self.organization}] {self.channel_code} â€” {self.channel_name}"

    class Meta:
        #db_table = "channel"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_channel_org"),
        #     models.Index(fields=("is_active",), name="idx_channel_active"),
        #     models.Index(fields=("kind",), name="idx_channel_kind"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "channel_code"),
                name="uniq_channel_org_code",
            ),
            models.UniqueConstraint(
                fields=("organization", "id"),
                name="uniq_channel_org_id",
            ),
            # Falls du den enum-artigen Check mÃ¶chtest, aktivieren:
            # models.CheckConstraint(
            #     name="ck_channel_kind",
            #     check=models.Q(kind__in=["shop", "marketplace"]),
            # ),
        ]


# ===== FILE: apps/sales/models/sales_order_line.py =====
# apps/sales/models/sales_order_line.py
"""
Purpose:
    Represents an individual line item in a sales order.
    Each line links to a product variant, with ordered quantity and price.

Context:
    Child of SalesOrder. Used to record which items are sold,
    at which price, and in what quantity. Basis for fulfillment and invoicing.

Fields:
    - organization (FK â†’ Organization): Tenant isolation.
    - sales_order (FK â†’ SalesOrder): Parent sales order reference.
    - row_no (SmallInteger): Unique row number per order.
    - variant (FK â†’ ProductVariant): Ordered product variant.
    - qty (Decimal): Ordered quantity (> 0).
    - price_at_order (Decimal): Net price per unit at time of order.
    - note (TextField): Optional line-level note.
    - is_active (Bool): Logical deletion flag.
    - created_at / updated_at: System timestamps.

Constraints:
    - (organization, sales_order, row_no) unique.
    - qty must be > 0.
    - price_at_order must be â‰¥ 0.

Example:
    >>> from apps.sales.models import SalesOrderLine
    >>> line = SalesOrderLine.objects.create(
    ...     organization=org,
    ...     sales_order=so,
    ...     row_no=1,
    ...     variant=variant,
    ...     qty=10,
    ...     price_at_order=99.99,
    ... )
    >>> print(line)
    [org=MyOrg] SO=SO-2025-001 #1 -> VAR=SKU123
"""


from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now
from django.core.validators import MinValueValidator


class SalesOrderLine(models.Model):
    #id = models.BigAutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="sales_order_lines",
    )

    sales_order = models.ForeignKey(
        "sales.SalesOrder",
        on_delete=models.PROTECT,
        related_name="sales_order_lines",
    )

    row_no = models.SmallIntegerField()  # unique within (org, sales_order)

    variant = models.ForeignKey(
        "catalog.ProductVariant",
        on_delete=models.PROTECT,
        related_name="sales_order_lines",
    )

    qty = models.DecimalField(
        max_digits=12,
        decimal_places=3,
        validators=[MinValueValidator(0.001)],
    )
    price_at_order = models.DecimalField(
        max_digits=12,
        decimal_places=4,
        validators=[MinValueValidator(0)],
    )
    note = models.TextField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization}] SO={self.sales_order} #{self.row_no} -> VAR={self.variant}"

    class Meta:
        # db_table = "sales_order_line"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_sol_org"),
        #     models.Index(fields=("sales_order",), name="idx_sol_so"),
        #     models.Index(fields=("variant",), name="idx_sol_variant"),
        #     models.Index(fields=("is_active",), name="idx_sol_act"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "sales_order", "row_no"),
                name="uniq_sol_org_so_row",
            ),
            models.CheckConstraint(
                name="ck_sol_qty_pos",
                check=Q(qty__gt=0),
            ),
            models.CheckConstraint(
                name="ck_sol_price_nn",
                check=Q(price_at_order__gte=0),
            ),
        ]




# ===== FILE: apps/sales/models/sales_order.py =====
# apps/sales/models/sales_order.py
"""
Purpose:
    Represents the header of a sales order, scoped by organization.
    Tracks business partner, currency, status, and important dates.

Context:
    Part of the sales domain. This table is the parent for sales order lines
    and drives fulfillment, invoicing, and reporting.

Fields:
    - organization (FK â†’ Organization): Tenant isolation.
    - customer (FK â†’ Customer): Buyer reference.
    - order_number (CharField): Unique per organization.
    - status (CharField): Lifecycle state (draft|confirmed|shipped|invoiced|cancelled).
    - currency (FK â†’ Currency): Transaction currency.
    - expected_date (DateField): Optional promised delivery date.
    - notes (TextField): Optional free-text notes.
    - is_active (Bool): Logical deletion flag.
    - created_at / updated_at: System timestamps.

Relations:
    - SalesOrder â†’ multiple SalesOrderLine (items).
    - Linked to invoicing, shipping, and pricing modules.

Constraints:
    - (organization, order_number) unique.
    - (organization, id) unique for safety.
    - Status restricted by check constraint.

Example:
    >>> from apps.sales.models import SalesOrder
    >>> so = SalesOrder.objects.create(
    ...     organization=org,
    ...     customer=cust,
    ...     order_number="SO-2025-001",
    ...     currency=eur,
    ... )
    >>> print(so)
    [org=MyOrg] SO SO-2025-001 (draft)
"""


from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now


class SalesOrder(models.Model):
    """Sales order header, scoped by organization."""

    #id = models.BigAutoField(primary_key=True)

    # Tenant
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="sales_orders",
    )

    # Business relations
    customer = models.ForeignKey(
        "partners.Customer",
        on_delete=models.PROTECT,
        related_name="sales_orders",
    )

    order_number = models.CharField(max_length=30)  # unique per org

    status = models.CharField(
        max_length=20,
        default="draft",  # draft|confirmed|shipped|invoiced|cancelled
    )

    currency = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="sales_orders",
    )

    expected_date = models.DateField(null=True, blank=True)
    notes = models.TextField(null=True, blank=True)

    is_active = models.BooleanField(default=True)

    # DB-managed timestamps
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization}] SO {self.order_number} ({self.status})"

    class Meta:
        # db_table = "sales_order"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_so_org"),
        #     models.Index(fields=("customer",),    name="idx_so_customer"),
        #     models.Index(fields=("status",),      name="idx_so_status"),
        #     models.Index(fields=("expected_date",), name="idx_so_expected"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "order_number"),
                name="uniq_so_org_number",
            ),
            models.UniqueConstraint(
                fields=("organization", "id"),
                name="uniq_so_org_id",
            ),
            models.CheckConstraint(
                name="ck_so_status",
                check=Q(status__in=["draft", "confirmed", "shipped", "invoiced", "cancelled"]),
            ),
        ]



# ===== FILE: apps/partners/models/supplier.py =====
# apps/partners/models/supplier.py
"""
Purpose:
    Represents supplier master data within an organization.
    Each supplier is uniquely identified by a supplier code and
    may include commercial, contact, and logistical information.

Context:
    Part of the partners app. Suppliers are organizationally scoped
    entities used for procurement, import mapping, and integrations.

Fields:
    - organization (FK â†’ core.Organization): Owning organization.
    - supplier_code (CharField, 20): Unique supplier code per organization.
    - is_active (BooleanField): Whether the supplier is active.
    - supplier_description (CharField, 200): Optional description/name.
    - contact_name (CharField, 100): Primary contact person.
    - email (CharField, 200): Contact email address.
    - phone (CharField, 50): Primary phone number.
    - website (CharField, 200): Website URL.
    - tax_id (CharField, 50): Tax/VAT identifier.
    - address_line1 (CharField, 200): Address line 1.
    - address_line2 (CharField, 200): Address line 2.
    - postal_code (CharField, 20): Postal/ZIP code.
    - city (CharField, 100): City name.
    - country_code (CharField, 2): ISO 3166-1 alpha-2 code.
    - payment_terms (CharField, 50): Payment term shorthand (e.g., NET30).
    - is_preferred (BooleanField): Whether marked as preferred supplier.
    - lead_time_days (SmallIntegerField): Typical lead time in days.
    - comment (CharField, 200): Optional internal comment.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple Suppliers

Used by:
    - Procurement workflows
    - Import mapping (apps/imports)
    - Inventory and purchase order processing

Depends on:
    - apps.core.models.Organization
    - Django ORM

Example:
    >>> from apps.partners.models import Supplier
    >>> s = Supplier.objects.create(
    ...     organization=org,
    ...     supplier_code="SUP001",
    ...     supplier_description="MegaParts Ltd.",
    ...     email="sales@megaparts.com"
    ... )
    >>> print(s)
    SUP001 â€” MegaParts Ltd.
"""


from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class Supplier(models.Model):
    """Supplier master data, scoped by organization (org_code)."""

    # PK BIGINT
    #id = models.BigAutoField(primary_key=True)

    # FK zu core.Organization(org_code); DB column bleibt 'org_code'
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,  # ON DELETE RESTRICT
        related_name="suppliers",
    )

    supplier_code = models.CharField(
        max_length=20,
    )
    is_active = models.BooleanField(
        default=True,
    )
    supplier_description = models.CharField(
        max_length=200,
        blank=True,
        default="",
    )

    # --- Common supplier fields (all optional; appended to preserve order) ---
    contact_name = models.CharField(
        max_length=100, blank=True, default="", help_text="Primary contact person name."
    )
    email = models.CharField(
        max_length=200, blank=True, default="", help_text="Contact email address."
    )  # Use CharField to avoid DB-specific validators for now.
    phone = models.CharField(
        max_length=50, blank=True, default="", help_text="Primary phone number."
    )
    website = models.CharField(
        max_length=200, blank=True, default="", help_text="Website URL."
    )
    tax_id = models.CharField(
        max_length=50, blank=True, default="", help_text="Tax/VAT identifier."
    )
    address_line1 = models.CharField(
        max_length=200, blank=True, default="", help_text="Address line 1."
    )
    address_line2 = models.CharField(
        max_length=200, blank=True, default="", help_text="Address line 2."
    )
    postal_code = models.CharField(
        max_length=20, blank=True, default="", help_text="Postal/ZIP code."
    )
    city = models.CharField(
        max_length=100, blank=True, default="", help_text="City."
    )
    country_code = models.CharField(
        max_length=2, blank=True, default="", help_text="ISO 3166-1 alpha-2 country code."
    )
    payment_terms = models.CharField(
        max_length=50, blank=True, default="", help_text="Payment terms shorthand (e.g., NET30)."
    )
    is_preferred = models.BooleanField(
        default=False, help_text="Mark as preferred supplier."
    )
    lead_time_days = models.SmallIntegerField(
        default=0, help_text="Typical lead time in days."
    )
    comment = models.CharField(
        max_length=200, blank=True, default="", help_text="comment"
    )  # Keep CharField for cross-DB portability; can switch to EmailField later.


    # Timestamps for parity with other tables
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"{self.supplier_code} â€” {self.supplier_description or 'Supplier'}"

    class Meta:
        # db_table = "supplier"
        verbose_name = "Supplier"
        verbose_name_plural = "Suppliers"
        # indexes = [
        #     models.Index(fields=["organization"], name="idx_supplier_org"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "supplier_code"],
                name="uniq_supplier_org_code",
            ),
            models.UniqueConstraint(
                fields=["organization", "id"],
                name="uniq_supplier_org_id",
            ),
        ]


# ===== FILE: apps/partners/models/customer.py =====
# apps/partners/models/customer.py
"""
Purpose:
    Represents customer master data within an organization.
    Each customer is uniquely identified by a customer code and
    may include contact and billing information.

Context:
    Part of the partners app. Customers are organizationally scoped
    entities used for sales, invoicing, and integrations.

Fields:
    - organization (FK â†’ core.Organization): Owning organization.
    - customer_code (CharField, 20): Unique customer code per organization.
    - is_active (BooleanField): Flag to indicate if the customer is active.
    - customer_description (CharField, 200): Optional description/name.
    - contact_name (CharField, 100): Primary contact person.
    - email (CharField, 200): Contact email address.
    - phone (CharField, 50): Primary phone number.
    - website (CharField, 200): Website URL.
    - tax_id (CharField, 50): Tax or VAT identifier.
    - address_line1 (CharField, 200): Address line 1.
    - address_line2 (CharField, 200): Address line 2.
    - postal_code (CharField, 20): Postal or ZIP code.
    - city (CharField, 100): City name.
    - country_code (CharField, 2): ISO 3166-1 alpha-2 code.
    - payment_terms (CharField, 50): Payment term shorthand (e.g., NET30).
    - comment (CharField, 200): Optional internal comment.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple Customers

Used by:
    - Sales, invoicing, procurement, and integration modules.

Depends on:
    - apps.core.models.Organization
    - Django ORM

Example:
    >>> from apps.partners.models import Customer
    >>> c = Customer.objects.create(
    ...     organization=org,
    ...     customer_code="CUST001",
    ...     customer_description="ACME Corp",
    ...     email="contact@acme.com"
    ... )
    >>> print(c)
    CUST001 â€” ACME Corp
"""


from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class Customer(models.Model):
    """Customer master data, scoped by organization (org_code)."""

    #id = models.BigAutoField(primary_key=True)

    # FK to core.Organization(org_code); DB column stays 'org_code'
    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,  # ON DELETE RESTRICT
        related_name="customers",
    )

    customer_code = models.CharField(
        max_length=20,
        help_text="Customer code (unique within organization).",
    )
    is_active = models.BooleanField(
        default=True,
        help_text="Whether the customer is active.",
    )
    customer_description = models.CharField(
        max_length=200,
        blank=True,
        default="",
        help_text="Optional description/name of the customer.",
    )

    # --- Common customer fields (all optional; appended to preserve order) ---
    contact_name = models.CharField(
        max_length=100, blank=True, default="", help_text="Primary contact person name."
    )
    email = models.CharField(
        max_length=200, blank=True, default="", help_text="Contact email address."
    )  # Keep CharField for cross-DB portability; can switch to EmailField later.
    phone = models.CharField(
        max_length=50, blank=True, default="", help_text="Primary phone number."
    )
    website = models.CharField(
        max_length=200, blank=True, default="", help_text="Website URL."
    )
    tax_id = models.CharField(
        max_length=50, blank=True, default="", help_text="Tax/VAT identifier."
    )
    address_line1 = models.CharField(
        max_length=200, blank=True, default="", help_text="Address line 1."
    )
    address_line2 = models.CharField(
        max_length=200, blank=True, default="", help_text="Address line 2."
    )
    postal_code = models.CharField(
        max_length=20, blank=True, default="", help_text="Postal/ZIP code."
    )
    city = models.CharField(
        max_length=100, blank=True, default="", help_text="City."
    )
    country_code = models.CharField(
        max_length=2, blank=True, default="", help_text="ISO 3166-1 alpha-2 country code."
    )
    payment_terms = models.CharField(
        max_length=50, blank=True, default="", help_text="Payment terms shorthand (e.g., NET30)."
    )
    comment = models.CharField(
        max_length=200, blank=True, default="", help_text="comment"
    )  # Keep CharField for cross-DB portability; can switch to EmailField later.

    # Timestamps to match project standard (DB defaults via NOW())
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"{self.customer_code} â€” {self.customer_description or 'Customer'}"

    class Meta:
        # db_table = "customer"
        verbose_name = "Customer"
        verbose_name_plural = "Customers"
        # indexes = [
        #     models.Index(fields=["organization"], name="idx_customer_org"),
        #     models.Index(fields=["is_active"], name="idx_customer_active"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=["organization", "customer_code"],
                name="uniq_customer_org_code",
            ),
            models.UniqueConstraint(
                fields=["organization", "id"],
                name="uniq_customer_org_id",
            ),
        ]


# ===== FILE: apps/procurement/models/purchase_order_line.py =====
# apps/procurement/models/purchase_order_line.py
"""
Purpose:
    Represents a line item within a purchase order, detailing the product,
    quantity, and price agreed at the time of order placement.

Context:
    Part of the procurement domain. PurchaseOrderLine items belong to a
    PurchaseOrder and specify the concrete products (via SupplierProduct),
    quantities, and pricing used in supplier transactions.

Fields:
    - organization (FK â†’ core.Organization): Owning organization.
    - purchase_order (FK â†’ procurement.PurchaseOrder): Parent purchase order.
    - row_no (SmallIntegerField): Line number, unique per order and organization.
    - supplier_product (FK â†’ procurement.SupplierProduct): Product reference
      from a supplier catalog.
    - qty (DecimalField): Quantity ordered, must be > 0.
    - price_at_order (DecimalField): Unit price at the time of order, >= 0.
    - note (TextField, optional): Freeform note for this line.
    - is_active (BooleanField): Whether the line is active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - PurchaseOrder â†’ multiple PurchaseOrderLines
    - SupplierProduct â†’ multiple PurchaseOrderLines
    - Organization â†’ multiple PurchaseOrderLines

Used by:
    - Procurement workflows for order fulfillment and invoicing.
    - Stock management and ERP integrations to update inventory.
    - Reporting on purchase details and supplier performance.

Depends on:
    - apps.core.models.Organization
    - apps.procurement.models.PurchaseOrder
    - apps.procurement.models.SupplierProduct

Example:
    >>> from apps.procurement.models import PurchaseOrderLine
    >>> pol = PurchaseOrderLine.objects.create(
    ...     organization=org,
    ...     purchase_order=po,
    ...     row_no=1,
    ...     supplier_product=sp,
    ...     qty=10,
    ...     price_at_order="99.99",
    ... )
    >>> print(pol)
    [org=1] PO=PO-2025-001 #1 -> SP=SP-123
"""


from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now
from django.core.validators import MinValueValidator


class PurchaseOrderLine(models.Model):
    #id = models.BigAutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="purchase_order_lines",
    )

    purchase_order = models.ForeignKey(
        "procurement.PurchaseOrder",
        on_delete=models.PROTECT,
        related_name="purchase_order_lines",
    )
    row_no = models.SmallIntegerField()  # unique je (org, po)

    supplier_product = models.ForeignKey(
        "procurement.SupplierProduct",
        on_delete=models.PROTECT,
        related_name="purchase_order_lines",
    )

    qty = models.DecimalField(
        max_digits=12, decimal_places=3,
        validators=[MinValueValidator(0.001)]
    )
    price_at_order = models.DecimalField(
        max_digits=12, decimal_places=4,
        validators=[MinValueValidator(0)]
    )
    note = models.TextField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization}] PO={self.purchase_order} #{self.row_no} -> SP={self.supplier_product}"

    class Meta:
        # db_table = "purchase_order_line"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_pol_org"),
        #     models.Index(fields=("purchase_order",), name="idx_pol_po"),
        #     models.Index(fields=("supplier_product",), name="idx_pol_sp"),
        #     models.Index(fields=("is_active",), name="idx_pol_act"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "purchase_order", "row_no"),
                name="uniq_pol_org_po_row",
            ),
            models.CheckConstraint(
                name="ck_pol_qty_pos",
                check=Q(qty__gt=0),
            ),
            models.CheckConstraint(
                name="ck_pol_price_nn",
                check=Q(price_at_order__gte=0),
            ),
        ]



# ===== FILE: apps/procurement/models/purchase_order.py =====
# apps/procurement/models/purchase_order.py
"""
Purpose:
    Represents a purchase order created by an organization to procure goods
    from a supplier. Captures order number, status, currency, and delivery info.

Context:
    Part of the procurement domain. Purchase orders are used to formalize
    and track purchasing activities, serving as the header document for
    ordered items.

Fields:
    - organization (FK â†’ core.Organization): Owning organization.
    - supplier (FK â†’ partners.Supplier): Supplier to whom the order is placed.
    - order_number (CharField, max 30): Unique identifier per organization.
    - status (CharField, max 20): Workflow state ("draft", "approved", "ordered",
      "received", "cancelled").
    - currency (FK â†’ core.Currency): Currency in which the order is placed.
    - expected_date (DateField, optional): Expected delivery date.
    - notes (TextField, optional): Freeform remarks.
    - is_active (BooleanField): Whether the order is currently active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple PurchaseOrders
    - Supplier â†’ multiple PurchaseOrders
    - Currency â†’ multiple PurchaseOrders
    - To be extended by PurchaseOrderLine for itemized order positions.

Used by:
    - Procurement workflows to manage supplier orders.
    - ERP processes for stock, invoicing, and financial reconciliation.
    - Reporting to track supplier performance and order statuses.

Depends on:
    - apps.core.models.Organization
    - apps.core.models.Currency
    - apps.partners.models.Supplier

Example:
    >>> from apps.procurement.models import PurchaseOrder
    >>> po = PurchaseOrder.objects.create(
    ...     organization=org,
    ...     supplier=sup,
    ...     order_number="PO-2025-001",
    ...     status="draft",
    ...     currency=eur,
    ... )
    >>> print(po)
    [org=1] PO PO-2025-001 (draft)
"""


from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now


class PurchaseOrder(models.Model):
    #id = models.BigAutoField(primary_key=True)

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="purchase_orders",
    )

    supplier = models.ForeignKey(
        "partners.Supplier",
        on_delete=models.PROTECT,
        related_name="purchase_orders",
    )

    order_number = models.CharField(max_length=30)  # unique je Org (s.u.)
    status = models.CharField(max_length=20, default="draft")  # draft|approved|ordered|received|cancelled

    currency = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="purchase_orders",
    )

    expected_date = models.DateField(null=True, blank=True)
    notes = models.TextField(null=True, blank=True)

    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return f"[org={self.organization_}] PO {self.order_number} ({self.status})"

    class Meta:
        # db_table = "purchase_order"
        # indexes = [
        #     models.Index(fields=("organization",), name="idx_po_org"),
        #     models.Index(fields=("supplier",),    name="idx_po_supplier"),
        #     models.Index(fields=("status",),      name="idx_po_status"),
        #     models.Index(fields=("expected_date",), name="idx_po_expected"),
        # ]
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "order_number"),
                name="uniq_po_org_number",
            ),
            models.CheckConstraint(
                name="ck_po_status",
                check=Q(status__in=["draft","approved","ordered","received","cancelled"]),
            ),
            models.UniqueConstraint(fields=("organization", "id"), name="uniq_po_org_id"),
        ]


# ===== FILE: apps/procurement/models/supplier_product.py =====
# apps/procurement/models/supplier_product.py
"""
Purpose:
    Defines the SupplierProduct entity, linking a ProductVariant with a Supplier.
    Stores supplier-specific identifiers, packaging details, ordering constraints,
    and procurement metadata. Forms the basis for managing supplier relationships
    for each variant.

Context:
    Part of the procurement domain. This model allows the system to store and
    differentiate how the same product variant is offered by different suppliers.
    It supports lead times, MOQs, and supplier-specific SKUs.

Fields:
    - organization (FK â†’ core.Organization): Tenant scoping.
    - supplier (FK â†’ partners.Supplier): The supplying vendor.
    - variant (FK â†’ catalog.ProductVariant): The product variant being supplied.
    - supplier_sku (CharField): Supplierâ€™s internal SKU/article number.
    - supplier_description (CharField): Supplier-provided description.
    - pack_size (DecimalField): Number of base units per supplier pack.
    - min_order_qty (DecimalField): Minimum order quantity at supplier.
    - lead_time_days (IntegerField): Delivery lead time in days.
    - is_active (BooleanField): Marks if the supplier product is valid.
    - is_preferred (BooleanField): Flags a preferred supplier.
    - notes (TextField): Free-text notes for procurement.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - Organization â†’ multiple SupplierProducts
    - Supplier â†’ multiple SupplierProducts
    - ProductVariant â†’ multiple SupplierProducts
    - SupplierProduct â†’ SupplierPrice (child records for price tiers)

Used by:
    - Procurement processes for creating purchase orders.
    - Supplier price management (via SupplierPrice and SupplierQuantityPrice).
    - ERP functions that calculate cost or choose preferred supplier.

Depends on:
    - apps.core.models.Organization
    - apps.partners.models.Supplier
    - apps.catalog.models.ProductVariant
    - apps.procurement.models.SupplierPrice (downstream dependency)

Example:
    >>> from apps.procurement.models import SupplierProduct
    >>> sp = SupplierProduct.objects.create(
    ...     organization=org,
    ...     supplier=supplier,
    ...     variant=variant,
    ...     supplier_sku="SUP-12345",
    ...     pack_size=10,
    ...     min_order_qty=50,
    ...     lead_time_days=7,
    ... )
    >>> print(sp)
    [org=1] supplier=SUP sku=SUP-12345 -> variant=SKU-001
"""



from __future__ import annotations

from django.db import models
from django.db.models import Q
from django.db.models.functions import Now
from django.core.validators import MinValueValidator


class SupplierProduct(models.Model):
    """
    Links a ProductVariant with a specific supplier.
    Holds supplier-specific identifiers, packaging,
    ordering constraints and procurement metadata.
    """

    organization = models.ForeignKey(
        "core.Organization",
        on_delete=models.PROTECT,
        related_name="supplier_products",
    )

    supplier = models.ForeignKey(
        "partners.Supplier",
        on_delete=models.PROTECT,
        related_name="supplier_products",
    )

    variant = models.ForeignKey(
        "catalog.ProductVariant",
        on_delete=models.PROTECT,
        related_name="supplier_products",
    )

    # Identification at supplier side
    supplier_sku = models.CharField(
        max_length=100,
        help_text="Article number / SKU as used by the supplier."
    )
    supplier_description = models.CharField(
        max_length=500,
        blank=True,
        default="",
        help_text="Optional description as provided by supplier (may differ from catalog description).",
    )

    # Procurement attributes
    pack_size = models.DecimalField(
        max_digits=10,
        decimal_places=3,
        default=1,
        validators=[MinValueValidator(0.001)],
        help_text="Number of base units in one pack as sold by supplier.",
    )
    min_order_qty = models.DecimalField(
        max_digits=10,
        decimal_places=3,
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Minimum order quantity (MOQ) at supplier.",
    )
    lead_time_days = models.IntegerField(
        default=0,
        validators=[MinValueValidator(0)],
        help_text="Standard lead time in days until delivery.",
    )

    # Flags
    is_active = models.BooleanField(default=True)
    is_preferred = models.BooleanField(
        default=False,
        help_text="Marks the preferred supplier for this variant."
    )

    notes = models.TextField(null=True, blank=True)

    # Timestamps
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    def __str__(self) -> str:
        return (
            f"[org={self.organization}] supplier={self.supplier} "
            f"sku={self.supplier_sku} -> variant={self.variant.sku}"
        )

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=("organization", "variant", "supplier"),
                name="uniq_supplier_product",
            ),
            models.CheckConstraint(
                name="ck_supplier_packsize_positive", check=Q(pack_size__gt=0)
            ),
            models.CheckConstraint(
                name="ck_supplier_moq_nonneg", check=Q(min_order_qty__gte=0)
            ),
            models.CheckConstraint(
                name="ck_supplier_leadtime_nonneg", check=Q(lead_time_days__gte=0)
            ),
        ]


# ===== FILE: apps/procurement/models/supplier_quantity_price.py =====
# apps/procurement/models/supplier_quantity_price.py
"""
Purpose:
    Defines quantity-based price tiers for a supplierâ€™s product.
    Complements SupplierPrice by enabling stepped pricing models when
    a single flat price (unit_price) is not sufficient.

Context:
    Part of the procurement domain. This model allows tiered pricing
    based on minimum order quantities. For example, buying 100 units
    may have a lower unit price than buying 10.

Fields:
    - supplier_price (FK â†’ SupplierPrice): Links to the supplier price header.
    - min_quantity (DecimalField): Minimum quantity for this tier.
    - unit_price (DecimalField): Net purchase price per unit (excl. VAT).

Relations:
    - SupplierPrice â†’ multiple SupplierQuantityPrice (tiers).
    - SupplierQuantityPrice belongs to exactly one SupplierPrice.

Used by:
    - Procurement calculations (choosing correct tier for an order).
    - ERP price imports from suppliers with graduated pricing.
    - PO line creation when selecting best available tier.

Depends on:
    - apps.procurement.models.SupplierPrice

Constraints:
    - Unique per (supplier_price, min_quantity).
    - Ordered by min_quantity ascending.

Example:
    >>> from apps.procurement.models import SupplierQuantityPrice
    >>> tier = SupplierQuantityPrice.objects.create(
    ...     supplier_price=sp,
    ...     min_quantity=100,
    ...     unit_price=9.99,
    ... )
    >>> print(tier)
    100+ â†’ 9.99 (EUR)
"""

from __future__ import annotations

from django.db import models
from django.core.validators import MinValueValidator


class SupplierQuantityPrice(models.Model):
    """
    Quantity-based price tier for a supplier's product.
    Used only when SupplierPrice.unit_price is NULL.
    """

    supplier_price = models.ForeignKey(
        "procurement.SupplierPrice",
        on_delete=models.CASCADE,
        related_name="quantity_prices",
        help_text="Parent supplier price record this tier belongs to.",
    )

    min_quantity = models.DecimalField(
        max_digits=10,
        decimal_places=3,
        validators=[MinValueValidator(0.001)],
        help_text="Minimum order quantity for this tier.",
    )
    unit_price = models.DecimalField(
        max_digits=12,
        decimal_places=4,
        validators=[MinValueValidator(0)],
        help_text="Net purchase price per unit (without VAT).",
    )

    class Meta:
        verbose_name = "Supplier Quantity Price"
        verbose_name_plural = "Supplier Quantity Prices"
        constraints = [
            models.UniqueConstraint(
                fields=("supplier_price", "min_quantity"),
                name="uniq_supplier_quantity_price",
            )
        ]
        ordering = ["min_quantity"]

    def __str__(self) -> str:
        return f"{self.min_quantity}+ â†’ {self.unit_price} ({self.supplier_price.currency})"



# ===== FILE: apps/procurement/models/supplier_price.py =====
# apps/procurement/models/supplier_price.py
"""
Purpose:
    Represents supplier-specific purchasing price headers. Defines currency,
    validity ranges, and optional flat prices. Tiered pricing details are
    maintained in SupplierQuantityPrice.

Context:
    Part of the procurement domain. SupplierPrice acts as the header for
    supplier pricing definitions. It ensures each supplier product has
    structured pricing information that may include validity periods and
    multiple tiers.

Fields:
    - supplier_product (FK â†’ procurement.SupplierProduct): The product this
      supplier price belongs to.
    - currency (FK â†’ core.Currency): Currency of the price list (ISO 4217).
    - unit_price (DecimalField, optional): Flat fallback price, without VAT.
    - min_quantity (DecimalField, optional): Minimum quantity for applying the
      flat unit price.
    - valid_from / valid_to (DateField, optional): Validity period of this price.
    - is_active (BooleanField): Whether this price is currently active.
    - created_at / updated_at (DateTimeField): Audit timestamps.

Relations:
    - SupplierProduct â†’ multiple SupplierPrices
    - SupplierPrice â†’ multiple SupplierQuantityPrices (via related_name="prices")
    - Currency â†’ multiple SupplierPrices

Used by:
    - Procurement for cost calculation, supplier integration, and order validation.
    - ERP workflows that determine applicable purchasing prices.

Depends on:
    - apps.procurement.models.SupplierProduct
    - apps.core.models.Currency
    - apps.procurement.models.SupplierQuantityPrice (child table)

Example:
    >>> from apps.procurement.models import SupplierPrice
    >>> sp = SupplierPrice.objects.create(
    ...     supplier_product=supplier_product,
    ...     currency=eur,
    ...     unit_price="12.50",
    ...     min_quantity="5",
    ... )
    >>> print(sp)
    SP-123 12.50 EUR
"""


from __future__ import annotations

from django.db import models
from django.db.models.functions import Now


class SupplierPrice(models.Model):
    """
    Supplier-specific purchasing price header.
    Holds currency, validity, and flags.
    Concrete price tiers are stored in SupplierQuantityPrice.
    """

    supplier_product = models.ForeignKey(
        "procurement.SupplierProduct",
        on_delete=models.CASCADE,
        related_name="prices",
    )

    currency = models.ForeignKey(
        "core.Currency",
        on_delete=models.PROTECT,
        related_name="supplier_prices",
        help_text="Currency of this price list (ISO 4217).",
    )

    # Optional: in some APIs there is a flat price without tiers
    unit_price = models.DecimalField(
        max_digits=12,
        decimal_places=4,
        null=True,
        blank=True,
        help_text="Fallback flat unit price (without VAT). May be omitted if quantity prices exist.",
    )
    min_quantity = models.DecimalField(
        max_digits=10,
        decimal_places=3,
        null=True,
        blank=True,
        help_text="Fallback minimum quantity for the flat price. Null if only tiers exist.",
    )

    # Validity
    valid_from = models.DateField(null=True, blank=True)
    valid_to = models.DateField(null=True, blank=True)

    # Meta
    is_active = models.BooleanField(default=True)
    created_at = models.DateTimeField(db_default=Now(), editable=False)
    updated_at = models.DateTimeField(db_default=Now(), editable=False)

    class Meta:
        verbose_name = "Supplier Price"
        verbose_name_plural = "Supplier Prices"
        constraints = [
            models.UniqueConstraint(
                fields=("supplier_product", "currency", "valid_from"),
                name="uniq_supplier_price_header",
            ),
        ]

    def __str__(self) -> str:
        if self.unit_price is not None:
            return f"{self.supplier_product} {self.unit_price} {self.currency.code}"
        return f"{self.supplier_product} {self.currency.code} (tiered)"


# ===== FILE: docs/ai_instructions/chatgpt_todo.txt =====
â€žScanne die Datei seitenweise und erstelle eine vollstÃ¤ndige Liste aller class â€¦(models.Model) Definitionen. Mach das in mehreren Schritten, bis du alle gefunden hast.â€œ



Modelle:
â€žScanne die Datei seitenweise und sammle alle class â€¦(models.Model) Definitionen.â€œ

Tabellen:
â€žScanne die Datei seitenweise und sammle alle SQL CREATE TABLE Statements.â€œ

Funktionen:
â€žScanne die Datei seitenweise und sammle alle def â€¦ Funktionen.â€œ

Admin-Views:
â€žScanne die Datei seitenweise und sammle alle class â€¦(admin.ModelAdmin) Definitionen.â€œ

Scanne die Datei seitenweise und erstelle eine vollstÃ¤ndige Liste aller
`class â€¦(models.Model)` Definitionen.
Arbeite solange automatisch weiter, bis du die gesamte Datei verarbeitet hast.
Frage mich NICHT nach jedem Schritt, sondern fahre eigenstÃ¤ndig fort,
bis die Liste komplett ist.


Scanne die Datei seitenweise und extrahiere nicht nur die Funktionssignaturen (`def â€¦`),
sondern auch den kompletten FunktionskÃ¶rper bis zur nÃ¤chsten Definition oder Klassen-Definition.
Arbeite automatisch weiter, bis die gesamte Datei verarbeitet ist.
Frage mich NICHT nach jedem Schritt.


